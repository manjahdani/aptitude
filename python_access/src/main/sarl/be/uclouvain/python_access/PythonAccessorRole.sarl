/** 
 * 
 */
package be.uclouvain.python_access

import io.sarl.core.Schedules
import java.io.FileReader
import java.util.HashMap
import org.json.simple.JSONObject
import org.json.simple.parser.JSONParser
import io.sarl.core.Initialize

/** 
 * @author manjah
 * 
 */
behavior PythonAccessorRole {
	
	uses Schedules, PythonTwinAccessCapacity
	
	protected var parser = new JSONParser();
	protected var jsonConfig : JSONObject;
	protected var partnerName : String;

	on Initialize {
		var belief = occurrence.parameters.get(0) as String
		var platformName = occurrence.parameters.get(1) as String
		connectToPython(belief,platformName)
	}
	def connectToPython(belief : String, platformName : String) {

		assert belief !== null, "Belief is null";
		assert platformName !== null, "PlatformName is null";
		
		var configPath = belief
		var jsonConfigtmp = parser.parse(new FileReader(configPath)) as JSONObject;
		var video = (new HashMap<String, String>)
		video.put("path", "F:/data/".concat(platformName).concat("/vdo.avi"))
		var pathRoi = new HashMap<String, String>
		pathRoi.put("path", "F:/data/".concat(platformName).concat("/roi.jpg"))
		var a = jsonConfigtmp.get("Preproc") as HashMap<String, HashMap<String, String>>
		a.put("roi", pathRoi)
		jsonConfigtmp.put("Video", video)
		jsonConfig = jsonConfigtmp
		activateAccess(jsonConfig)
	}

	on PartnerTrackingFound {
		synchronized(this)
		this.partnerName = occurrence.partnerName
		//info("Tracking Partner found: " + this.partnerTrackingName)
	}
	@SuppressWarnings("potential_field_synchronization_problem")
	on PartnerDetectionFound {
		this.partnerName = occurrence.partnerName
		// info("Detection partner found: " + this.partnerDetectionName)
		task("wait").in(2000) [
			updateStreamAccess(1)
			task("wait").cancel // PLAY
			]
	}

}
