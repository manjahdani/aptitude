/** 
 * 
 */
package be.uclouvain.python_access

import be.uclouvain.python_access.messages.ActionMessage
import be.uclouvain.python_access.messages.RequestMessage
import io.sarl.core.AgentTask
import io.sarl.core.Schedules
import java.util.UUID
import org.json.simple.JSONObject
import io.sarl.core.Logging
import java.util.concurrent.atomic.AtomicReference

/** 
 * @TODO: write a description
 * 
 * @author $Author: manjahdani$
 * @version $0.0.1$
 * @date $31/03/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */

abstract skill PythonTwinAccess implements PythonTwinAccessCapacity {
	uses Schedules, Logging
	
	protected val topicRequestSub = new AtomicReference<UUID>
	protected val topicSignalAcquisition = new AtomicReference<UUID>

	protected var pendingRequestID = new AtomicReference<UUID>
	protected var requestTask : AgentTask

	
	def install {
		
		topicRequestSub.set(CommunicationManager.instance.subscribeTopic("request", this)) 
	}

	def prepareUninstallation {
		// Function invoked when the skill is preparing to be uninstalled from the owner, but before the owner is destroyed.
		// You should put all the resource release statements that should be executed before the owner is destroyed.
		//info("Preparing the uninstallation of the skill")
	}

	
	def uninstall {
		
		
		
		if (topicRequestSub.get !== null) {
			CommunicationManager.instance.unsubscribeTopic(topicRequestSub.toString)
			topicRequestSub.set(null)
		}
		if (topicSignalAcquisition.get !== null) {
			CommunicationManager.instance.unsubscribeTopic(topicSignalAcquisition.toString)
			topicSignalAcquisition.set(null)
		}
	}

	
	def activateAccess(jsonConfig : JSONObject) {
		this.pendingRequestID.set(UUID.randomUUID)
		this.requestTask = every(1000) [
			debug("Python partner not found, send discovery message")
			var requestMessage = new RequestMessage()
			requestMessage.requestID = this.pendingRequestID.get
			
			requestMessage.agentID = owner.ID.toString
			requestMessage.jsonConfig = jsonConfig.toString
			CommunicationManager.instance.publishMessage(topicRequestSub.toString, requestMessage)
		]
	}

	
	def updateStreamAccess(actionID : int) {
		debug("Updating Stream Access" + actionID)
		updateStreamAccess(actionID, -1)
	}

	def updateStreamAccess(actionID : int, newFrameNumber : int) {
		//info("I am sending the action: " + actionID)
		var actionMessage = new ActionMessage() // @TODO : Strange way of doing it
		actionMessage.actionID = actionID
		if (newFrameNumber != -1) {
			actionMessage.newFrameNumber = newFrameNumber
		}
		CommunicationManager.instance.publishMessage(topicSignalAcquisition.toString, actionMessage)
	}
} 
 
 

