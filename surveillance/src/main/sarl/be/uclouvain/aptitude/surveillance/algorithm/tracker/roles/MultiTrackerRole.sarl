/** 
 * 
 */
package be.uclouvain.aptitude.surveillance.algorithm.tracker.roles

import be.uclouvain.aptitude.surveillance.algorithm.Algorithm
import be.uclouvain.aptitude.surveillance.algorithm.LastFrame
import be.uclouvain.aptitude.surveillance.algorithm.tracker.events.ResumeTrackingMission
import be.uclouvain.aptitude.surveillance.algorithm.tracker.events.TrackingRequest
import be.uclouvain.organisation.events.AddMember
import be.uclouvain.organisation.platform.ObserverRole
import be.uclouvain.organisation.platform.PlatformOrganizationInfo
import be.uclouvain.organisation.platform.events.AddMission
import be.uclouvain.organisation.platform.events.ComputationalRessources
import be.uclouvain.organisation.platform.events.PauseMission
import be.uclouvain.organisation.platform.events.ScenarioInfo
import be.uclouvain.organisation.platform.events.ScenarioInfoRequest
import be.uclouvain.organisation.platform.util.HyperParameters
import be.uclouvain.organisation.platform.util.Metadata
import be.uclouvain.organisation.platform.util.SurveillanceMissionData
import be.uclouvain.python_access.BBoxes2DResult
import io.sarl.core.AgentSpawned
import io.sarl.core.Behaviors
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.OpenEventSpaceSpecification
import java.util.Collections
import java.util.HashMap
import java.util.LinkedList
import java.util.TreeMap
import java.util.UUID

/** 
 * @author manjah
 * 
 */
 
behavior MultiTrackerRole extends ObserverRole {
	uses Logging, Lifecycle, InnerContextAccess , Behaviors, ExternalContextAccess
	
	var detectors = new TreeMap<String, Metadata> // @FIXME HIGH LOGICIEL PARAMETERS ?
	
	
	protected val detector_innerTrackerMap = Collections.synchronizedMap(new HashMap<String, UUID>)
	protected val innerTracker_detectorsMap = Collections.synchronizedMap(new HashMap<UUID, String>)
	protected val innerTracker_ParametersMap = Collections.synchronizedMap(new HashMap<UUID, HyperParameters>)

	val hyperParametersToBeTested  = Collections.synchronizedList(new LinkedList<HyperParameters>)
	
	protected val activeProviders = Collections.synchronizedMap(new HashMap<String, UUID>) // Detector and its ID

	on Initialize {
		info("Multi-tracker role started.")
		emit(selfSpace, new ScenarioInfoRequest)
		hyperParametersToBeTested.addAll(occurrence.parameters.get(1) as LinkedList<HyperParameters>)
		detectors.putAll(occurrence.parameters.get(2) as TreeMap<String, Metadata>)
	}

	on ScenarioInfo {
		assert occurrence.client_id !== null, "Received computatation_location null"
		computation_location.set(occurrence.client_id)
		updateContextInfo(occurrence.organizationContext, occurrence.privateCommunicationChannelID)
		checkList.replace("context", true)
		checkList.replace("computation_location", true)
	}
	on TrackingRequest {
		
		val agentID = occurrence.agentID
		info("Reactivating Access - " + agentID + " - " + innerTracker_detectorsMap.get(agentID) + "for mID" + occurrence.missionID)
		
		
		if (innerTracker_detectorsMap.get(agentID) == "YOLO-COCO"){
			info("We are more in a horizontal view")
		}
		else if (innerTracker_detectorsMap.get(agentID) == "YOLO") {
			info("We are in a vertical view")
		}
		wake(new ResumeTrackingMission(occurrence.missionID,innerTracker_detectorsMap.get(agentID)))[it.ID==this.ID]
		
	}	
	
	on LastFrame {
		
		var detectorToPause = innerTracker_detectorsMap.get(occurrence.source.ID)
		info("Pausing my provider = " + detectorToPause)
		var detectorID = activeProviders.get(detectorToPause)
		
		val mData = orderedMissionList.values.findFirst[signalID==detectorID]
		info("Pausing mission" + mData.missionID + detectorID)
		emit(providers.get(detectorID), new PauseMission(mData.missionID))[it.ID == detectorID]
	}

	on BBoxes2DResult {
		
		if(occurrence.bboxes2D.frameNumber <5){
		info("Sending results of frame #" + occurrence.bboxes2D.frameNumber + 
			" from " + occurrence.providerName + " to " + detector_innerTrackerMap.get(occurrence.providerName))
		}
		// We send to the sub-process meant to analyse the data of the provider. 
		// For example, agent 1 process the data sent from detector A. 
		wake(new BBoxes2DResult(occurrence.bboxes2D))[it.ID == detector_innerTrackerMap.get(occurrence.providerName)] 
	}
	
	def startRole {
		for(d:detectors.keySet){
			val internalMissionID = UUID.randomUUID
			val newInternalMission = new SurveillanceMissionData(internalMissionID, this.ID, organizationContext.get.ID,
				detectors.get(d).performance, false)
			orderedMissionList.put(internalMissionID, newInternalMission)
			innerTracker_ParametersMap.put(internalMissionID, new HyperParameters(detectors.get(d).performance, false))
			var comSpace = organizationContext.get.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID) // An internal space to communicate with other roles.
			comSpace.registerStrongParticipant(asEventListener)
			providers.put(internalMissionID, comSpace)
			detector_innerTrackerMap.put(d, internalMissionID)
			innerTracker_detectorsMap.put(internalMissionID, d)
			spawnInContextWithID(Algorithm, internalMissionID, innerContext,
				ADN.get.cloneChildWithID(internalMissionID))
			requestAlgorithm(internalMissionID,d,"DETECTOR")
			
		}
		
		//orderedMissionList.put... 
	}
	
	on AgentSpawned {

		// In this, we choose that the missionID is equivalent to the subprocess ID
		val mbID = occurrence.agentID
		if(memberAgents.contains(mbID)){
		
		info("MemberJoined" + mbID + "type" + occurrence.agentType)
		wake(
			new PlatformOrganizationInfo(organizationContext.get, privateOrganizationSpace.get.spaceID.ID,
				this.ADN.get.platformName))[it.ID == mbID]
		wake(new ComputationalRessources(computation_location.get))[it.ID == mbID]

		emit(selfSpace, new AddMember(mbID, providers.get(mbID)))
		wake(new AddMission(mbID, providers.get(mbID).spaceID.ID)) [
			it.ID == mbID
		]}
	}
	on MemberJoined {
		
		
		
	}
}
