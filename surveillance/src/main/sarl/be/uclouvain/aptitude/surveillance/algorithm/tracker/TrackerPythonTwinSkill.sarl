package be.uclouvain.aptitude.surveillance.algorithm.tracker


import io.sarl.core.Behaviors
import io.sarl.core.Schedules
import be.uclouvain.aptitude.surveillance.algorithm.ObserverPythonAccess
import be.uclouvain.python_access.messages.BaseMessage
import be.uclouvain.python_access.messages.BBoxes2DTrackMessage
import be.uclouvain.python_access.messages.RequestMessage
import be.uclouvain.python_access.CommunicationManager
import be.uclouvain.python_access.BBoxes2DTrackResult
import be.uclouvain.python_access.PartnerTrackingFound
import java.util.ArrayList
import be.uclouvain.aptitude.surveillance.algorithm.util.BBoxe2D
import be.uclouvain.aptitude.surveillance.algorithm.util.BBOX
import java.util.Arrays
import io.sarl.core.Logging
import java.util.concurrent.atomic.AtomicInteger

/** 
 * @TODO: write a description
 * 
 * @author $Author: manjahdani$
 * @version $0.0.1$
 * @date $31/03/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */


skill TrackerPythonTwinSkill extends ObserverPythonAccess implements TrackerPythonTwinCapacity {
	
	uses Behaviors, Schedules, Logging

	val FRAME_WIDTH = 1920.0 // @FIXME MEDIUM hardcoded value
	var FRAME_HEIGHT = 1080.0 // @FIXME MEDIUM hardcoded value
	
	//val FRAME_WIDTH = 960.0 // @FIXME MEDIUM hardcoded value
	//var FRAME_HEIGHT = 540.0 // @FIXME MEDIUM hardcoded value
	
	var totalTrackerTime : double = 0
	var totalDetectorTime : double = 0
	
	var a = new AtomicInteger(0)
	
	def update(m : BaseMessage) {
		if (m instanceof BBoxes2DTrackMessage) {
			wake(new BBoxes2DTrackResult(m))[it.ID == owner.ID] 
		} else if (m instanceof RequestMessage) {
			onRequestMessage(m)
		}
	}

	private def onRequestMessage(message : RequestMessage) {
		if (message.ack && message.requestID == this.pendingRequestID) {
			requestTask.cancel
			CommunicationManager.instance.unsubscribeTopic(topicRequestSub.toString)
			topicRequestSub = null
			val topicName = "tracking_" + owner.ID.toString + "_" + message.clientName
			topicSignalAcquisition = CommunicationManager.instance.subscribeTopic(topicName, this)
			wake(new PartnerTrackingFound(message.clientName))
		}
	}
	
	@Pure def formatConversion(track : BBoxes2DTrackMessage) : ArrayList<BBoxe2D> {

		totalDetectorTime += track.detectionTime
		totalTrackerTime += track.trackingTime
		
		var ratio_width = FRAME_WIDTH / track.dimWidth
		var ratio_height = FRAME_HEIGHT / track.dimHeight
		
		var tmp : ArrayList<BBoxe2D> = newArrayList

		for (var i = 0; i < track.numberObjects; i++) {
			var X = track.bboxes.get(4 * i) * ratio_width
			var Y = 	track.bboxes.get(4 * i + 1) * ratio_height
			var W = track.bboxes.get(4 * i + 2) * ratio_width
			var H = track.bboxes.get(4 * i + 3) * ratio_height
			var classID = track.classIDs.get(i)
			var globalID = track.globalIDs.get(i)
			var conf = track.detConfs.get(i)
			tmp.add(new BBoxe2D(new BBOX(X, Y, W, H), conf, globalID, classID, track.frameNumber))
		}
		return tmp
	}
	
	@SuppressWarnings("discouraged_reference")
	def print(track : BBoxes2DTrackMessage) {
		
		 println("***********************")
		 println("* Tracking " + track.frameNumber)
		 println("*  " + track.trackingTime)
		 println("*  " + Arrays.toString(track.globalIDs))
		 println("*  " + Arrays.toString(track.bboxes))
		 println("*  " + Arrays.toString(track.classIDs))
		 println("*  " + Arrays.toString(track.detConfs))
		 println("*  " + track.lastFrame)
		 println("***********************")
	}
	
	def test {
		info(a.incrementAndGet)
	}
	
//	def getTrack(detectionMessage : BBoxes2DMessage) {
//		CommunicationManager.instance.publishMessage(topicSignalAcquisition, detectionMessage)
//	}	
}

