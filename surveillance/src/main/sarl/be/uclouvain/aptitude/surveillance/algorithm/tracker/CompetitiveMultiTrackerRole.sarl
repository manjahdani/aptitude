/** 
 * 
 */
package be.uclouvain.aptitude.surveillance.algorithm.tracker

import be.uclouvain.aptitude.surveillance.algorithm.Algorithm
import be.uclouvain.organisation.platform.ComputationalRessources
import be.uclouvain.aptitude.surveillance.algorithm.util.HyperParameters
import be.uclouvain.organisation.AddMember
import be.uclouvain.organisation.platform.AddMission
import be.uclouvain.organisation.platform.HyperParametersRequest
import be.uclouvain.organisation.platform.ProcessingHyperParameters
import be.uclouvain.organisation.told.util.AlgorithmInfo
import be.uclouvain.python_access.BBoxes2DResult
import io.sarl.core.Behaviors
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.lang.core.AgentContext
import java.util.Collections
import java.util.HashMap
import java.util.LinkedList
import java.util.UUID
import io.sarl.core.Schedules


/** 
 * @author manjah
 * 
 */
 
behavior CompetitiveMultiTrackerRole {
	uses Logging, Lifecycle, InnerContextAccess, Schedules , Behaviors
	
	val detectors = newArrayList("TinyYOLO", "YOLO") // @FIXME its logiciel parameters or not ?
	
	protected val sub_processes = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the role and data providers
	protected val parrallelProcess = Collections.synchronizedMap(new HashMap<String, UUID>)
	protected val providers_HP = Collections.synchronizedMap(new HashMap<UUID, HyperParameters>)

	protected var Computational_Location : String
	protected var privateTOLDSpace : OpenEventSpace
	protected var TOLDContext : AgentContext
	
	on Initialize {
		info("Competitive multi-tracker role started.")

		var hyperParametersToBeTested : LinkedList<HyperParameters>
		var observerADN : AlgorithmInfo
		try {hyperParametersToBeTested = occurrence.parameters.get(0) as LinkedList<HyperParameters>}
		catch (e : ClassCastException) {
			warning("Could not cast Initialise parameters 0 to a LinkedList")
		}
		try {
			observerADN = occurrence.parameters.get(1) as AlgorithmInfo
		} 
		catch (e : ClassCastException) {
			warning("Could not cast Initialise parameters 1 to AlgorithmInfo")
		}
		try{
			TOLDContext = occurrence.parameters.get(2) as AgentContext
			assert TOLDContext !== null, "Argument of toldContext null"
		}
		catch (e : ClassCastException) {
			warning("Could not cast Initialise parameters 2 to AgentContext")
		}

		try {
			privateTOLDSpace = occurrence.parameters.get(3) as OpenEventSpace
			assert privateTOLDSpace !== null, "Parameter of privateTOLDSpace null"
		} catch (e : ClassCastException) {
			warning("Could not cast Initialise parameters 3 to OpenEventSpace")
		}
		
		Computational_Location = occurrence.parameters.get(4) as String
		

		
		for (param : hyperParametersToBeTested) {
		var cloneID = UUID.randomUUID
		providers_HP.put(cloneID, param)
		var tmp = observerADN.cloneChild
		tmp.setID(cloneID) //@FIXME better way to code that.
		spawnInContextWithID(Algorithm, cloneID, innerContext,tmp) // Spawn a sub-process specialised using the hyperParameters s
		var comSpace : OpenEventSpace = innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID) // An internal space to communicate with other roles.
		comSpace.registerStrongParticipant(asEventListener)
		sub_processes.put(cloneID, comSpace)
		parrallelProcess.put(detectors.get(param.sensitivity), cloneID)
		}

		task("a").in(400) [
			for (cloneID : sub_processes.keySet) {
				wake(new AddMission(sub_processes.get(cloneID)))[it.ID == cloneID]
				wake(new ComputationalRessources(Computational_Location))[it.ID == cloneID]
			}
			task("a").cancel
		] //@FIXME HIGH something to do with synchronization
		
		
		task("b").in(500) [
		for (cloneID : sub_processes.keySet)
		{
			privateTOLDSpace.emit(this.ID, new AddMember(cloneID, sub_processes.get(cloneID)))[it.ID == TOLDContext.ID]
		}
		task("b").cancel
		]
		
	}

	on HyperParametersRequest {
	
		var providerID = occurrence.source.ID
		// We decide that derived role handles the parameters request of inner-agents.
		
		if (getMemberAgents.contains(providerID)) {
			var param = providers_HP.get(providerID)
			info("Inner tracker request from -" + providerID.toString.substring(0, 5) + " sends  s :" + param.sensitivity)
			sub_processes.get(providerID).emit(this.ID, new ProcessingHyperParameters(param.sensitivity, false)) [
				it.ID == providerID
			]
		}
	}

	on Destroy {
		// Event trigger when the behavior is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The behavior was stopped.")
	}



	on BBoxes2DResult {
		
		if(occurrence.bboxes2D.frameNumber <5){
		debug("Sending results of frame #" + occurrence.bboxes2D.frameNumber + 
			" from " + occurrence.providerName + " to " + parrallelProcess.get(occurrence.providerName))}
		// We send to the sub-process meant to analyse the data of the provider. For example, agent 1 process the data sent from detector A. 
		wake(new BBoxes2DResult(occurrence.bboxes2D))[it.ID == parrallelProcess.get(occurrence.providerName)] 
	

	/* 
	 * if (!providers.keySet.contains(occurrence.source.ID)) {
	 * providers.put(occurrence.source.ID, null) 	// @FIXME HIGH to correct;
	 * } // @FIXME It is not necessary
	 */
	}
}
