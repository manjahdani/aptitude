/** 
 * 
 */
package be.uclouvain.aptitude.surveillance.algorithm.tracker

import be.uclouvain.aptitude.surveillance.algorithm.Algorithm
import be.uclouvain.aptitude.surveillance.algorithm.LastFrame
import be.uclouvain.organisation.events.AddMember
import be.uclouvain.organisation.events.SignalID
import be.uclouvain.organisation.platform.ObserverRole
import be.uclouvain.organisation.platform.events.AddMission
import be.uclouvain.organisation.platform.events.HyperParametersRequest
import be.uclouvain.organisation.platform.events.ProcessingHyperParameters
import be.uclouvain.organisation.platform.events.RemoveMission
import be.uclouvain.organisation.platform.util.HyperParameters
import be.uclouvain.organisation.platform.util.SurveillanceMissionData
import be.uclouvain.organisation.told.util.AlgorithmInfo
import be.uclouvain.python_access.BBoxes2DResult
import io.sarl.core.Behaviors
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.core.Schedules
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.LinkedList
import java.util.UUID

/** 
 * @author manjah
 * 
 */
 
behavior MultiTrackerRole extends ObserverRole {
	uses Logging, Lifecycle, InnerContextAccess, Schedules , Behaviors, ExternalContextAccess
	
	var detectors : ArrayList<String>  // @FIXME HIGH LOGICIEL PARAMETERS ?
	
	protected val sub_processes = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the role and data providers
	protected val detector_innerTrackerMap = Collections.synchronizedMap(new HashMap<String, UUID>)
	protected val innerTracker_detectorsMap = Collections.synchronizedMap(new HashMap<UUID, String>)
	protected val innerTracker_ParametersMap = Collections.synchronizedMap(new HashMap<UUID, HyperParameters>)
	protected var computation_Location : String

	val hyperParametersToBeTested  = Collections.synchronizedList(new LinkedList<HyperParameters>)
	
	protected val activeProviders = Collections.synchronizedMap(new HashMap<String, UUID>) // Detector and its ID

	on Initialize {
		info("Multi-tracker role started.")
		emit(selfSpace, new ScenarioInfo)
		hyperParametersToBeTested.addAll(occurrence.parameters.get(0) as LinkedList<HyperParameters>)
		ADN.set(occurrence.parameters.get(1) as AlgorithmInfo)
		detectors = occurrence.parameters.get(5) as ArrayList<String>
		
		
		
		
		

		


		detector_innerTrackerMap.put(detectors.get(param.sensitivity), cloneID)
		innerTracker_detectorsMap.put(cloneID,detectors.get(param.sensitivity))
		


		
	}

	
	on TrackingRequest {
		debug("Reactivating Access - " + occurrence.competitorID + " - " + innerTracker_detectorsMap.get(occurrence.competitorID))
		
		if (innerTracker_detectorsMap.get(occurrence.competitorID) == "YOLO-COCO"){
			info("We are more in a horizontal view")
		}
		else if (innerTracker_detectorsMap.get(occurrence.competitorID) == "YOLO") {
			info("We are in a vertical view")
		}
		wake(new ResumeTrackingMission(innerTracker_detectorsMap.get(occurrence.competitorID)))[it.ID==this.ID]
		
	}	
	on HyperParametersRequest {
	
		var providerID = occurrence.source.ID
		// We decide that derived role handles the parameters request of inner-agents.
		
		if (getMemberAgents.contains(providerID)) {
			var param = innerTracker_ParametersMap.get(providerID)
			debug("Inner tracker request from -" + providerID.toString.substring(0, 5) + " sends  s :" + param.sensitivity)
			
			emit(sub_processes.get(providerID), new ProcessingHyperParameters(param.sensitivity, false)) [
				it.ID == providerID
			]
		}
	}
	
	on SignalID{

		
		
		
		emit(privateTOLDSpace, new AddMember(cloneID, sub_processes.get(cloneID)))[it.ID == TOLDContext.ID]
		wake(new AddMission(sub_processes.get(cloneID)))[it.ID == cloneID]
		orderedMissionList.
		
	}
	
	on LastFrame {
		
		debug("detectorToRemove = " + innerTracker_detectorsMap.get(occurrence.source.ID))
		var detectorToRemove = innerTracker_detectorsMap.get(occurrence.source.ID)
		var id = activeProviders.get(detectorToRemove)
		wake(new RemoveMission(id))[it.ID==this.ID]
	}

	on BBoxes2DResult {
		
		if(occurrence.bboxes2D.frameNumber <5){
		debug("Sending results of frame #" + occurrence.bboxes2D.frameNumber + 
			" from " + occurrence.providerName + " to " + detector_innerTrackerMap.get(occurrence.providerName))
		}
		// We send to the sub-process meant to analyse the data of the provider. 
		// For example, agent 1 process the data sent from detector A. 
		wake(new BBoxes2DResult(occurrence.bboxes2D))[it.ID == detector_innerTrackerMap.get(occurrence.providerName)] 
	}
	
	def startRole {
		val detectors = new HashMap<String, Integer>

		val externalMissionID = occurrence.missionID... 
		for(d:detectors.keySet){
			val internalMissionID = UUID.randomUUID
			val newInternalMission = new SurveillanceMissionData(internalMissionID, this.ID, organizationContext.get.ID,
				detectors.get(d), false)
			orderedMissionList.put(internalMissionID, newInternalMission)
			innerTracker_ParametersMap.put(internalMissionID, new HyperParameters(detectors.get(d),false))
			spawnInContextWithID(Algorithm, internalMissionID, innerContext, ADN.get.cloneChild(internalMissionID))
		}
		
		orderedMissionList.put... 
	}
	
}

event ResumeTrackingMission {
	val missionID : UUID
	val detector : String

	new(mID : UUID, d : String) {
		this.missionID= mID
		this.detector = d
	}
}
