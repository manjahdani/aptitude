package be.uclouvain.aptitude.surveillance.algorithm.tracker

import be.uclouvain.aptitude.surveillance.algorithm.LastFrame
import be.uclouvain.aptitude.surveillance.algorithm.detector.PauseMission
import be.uclouvain.aptitude.surveillance.algorithm.util.BBoxe2D
import be.uclouvain.aptitude.surveillance.algorithm.util.HyperParameters
import be.uclouvain.organisation.platform.ObserverRole
import be.uclouvain.python_access.BBoxes2DTrackResult
import be.uclouvain.python_access.messages.BBoxes2DTrackMessage
import io.sarl.core.Behaviors
import io.sarl.core.Logging
import java.util.ArrayList
import java.util.LinkedList
import io.sarl.core.ExternalContextAccess
import be.uclouvain.organisation.platform.events.RemoveMission
import be.uclouvain.organisation.platform.events.LeavePlatform
import java.util.UUID

/** 
 * @FIXME LOW IMPROVEMENT : the Hazelcast only need to send the frame number and the ids.  Will it make sens ? 
 * that contains the information requested upon approved request from another. 
 * 
 * @FIXME MEDIUM
 * It does make sens to have a certain window of information in memory and the 
 * other one stored in a database. Therefore, the database with a certain window in situ and otherwise stored in TOLD
 * We need to find a way such that the information is synchronized before potential fusion 
 *
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */
behavior TrackerRole extends ObserverRole {
	
	uses Logging, TrackerPythonTwinCapacity, Behaviors, ExternalContextAccess


	val detectors = newArrayList("YOLO", "YOLO-COCO") // @FIXME should be given by the Analyst which makes it configurable ?
	
	var totalTrackerTime : double = 0
	var totalDetectorTime : double = 0


	var frameLimit : int = 500
	
	on LastFrame {
		debug("Transmitting to my listeners" + listeners.keySet)
		for (l : listeners.keySet) {
			emit(listeners.get(l),
				new LastFrame(
					occurrence.frameNumber, 
					occurrence.pred_file_Path, 
					occurrence.total_time_detection,
					occurrence.total_time_tracking, 
					occurrence.observerID))[it.ID==l]
			//listeners.get(l).emit(this.ID,)[it.ID == l]}
		}
	}
	
	on RemoveMission{
		debug("Received a request to remove a mission")
		emit(providers.get(occurrence.expertID),new PauseMission)[it.ID==occurrence.expertID]
	}
	
	on LeavePlatform {
		// join(BaseContext.ID, BaseSpace.spaceID.ID)
		info("ObserverTrackerLeaving")
		updateStreamAccess(4)
		// leave(PlatformID)
	}

	on BBoxes2DTrackResult {

		totalDetectorTime += occurrence.bboxes2DTrack.detectionTime
		totalTrackerTime += occurrence.bboxes2DTrack.trackingTime
		
		var tmp : ArrayList<BBoxe2D> = formatConversion(occurrence.bboxes2DTrack)

		wake(new TrackingPerception(tmp, occurrence.bboxes2DTrack.frameNumber))[it.ID == this.ID] // For entity
		for (l : listeners.keySet) {
			emit(listeners.get(l), new TrackingPerception(tmp, occurrence.bboxes2DTrack.frameNumber)) [
				it.ID == l
			]		
		}
		
		if (occurrence.bboxes2DTrack.frameNumber % 250 ==0){
			info("Processed #" + occurrence.bboxes2DTrack.frameNumber +"frames")
		}
		if (occurrence.bboxes2DTrack.lastFrame || occurrence.bboxes2DTrack.frameNumber > frameLimit) {
			emit(selfSpace, new TrackingTaskOver)
			
			debug("Tracking job done... " + "sending the information to " + listeners.keySet)
			
			for (l : listeners.keySet) {
				emit(listeners.get(l),
					new LastFrame(
						occurrence.bboxes2DTrack.frameNumber,
					("F:\\Database\\".concat(this.ID.toString) + ".txt"),
					totalDetectorTime, 
					totalTrackerTime,
					observerADN.get.ID))[it.ID == l]
			}

		/** 
			listeners.get(l).emit(this.ID,
			new LastFrame(
				occurrence.bboxes2DTrack.frameNumber, 
				("F:\\Database\\".concat(this.ID.toString) + ".txt"),
				totalDetectorTime, 
				totalTrackerTime))[it.ID == l]
			}*/
		}
	
	}
	
	on ResumeTrackingMission {
		info("Resuming my mission with "+ occurrence.detector)
		setSkill(new TrackerPythonTwinSkill)
		registerBehavior(new SingleTrackerRole(this.owner), observerADN.get.belief, MD.location,computation_location)
		info("Come here " + occurrence.detector)
		MD.dynamicAdaptation = false
		
		requestAlgorithm(occurrence.detector, "DETECTOR")
	}
	
	override startProcessingRole (mID : UUID) {
		if (missionList.get(mID).isDynamicAdaptationEnabled) 
		{
			var hyperParatermersToBeTested = new LinkedList<HyperParameters>
			var iter = 0 // @FIXME LOW Quick but not robust strategy as if the order of detectors change the system could get confused.
			
			for (d : detectors) {
				hyperParatermersToBeTested.add(new HyperParameters(iter))
				iter += 1
			}
			
			registerBehavior(new CompetitiveMultiTrackerRole(owner), hyperParatermersToBeTested, this.observerADN,computation_location, detectors)
			
			for (detector : detectors) {
				
				info("Come here : " + detector)
				requestAlgorithm(detector, "DETECTOR")
				}
				
		} 
		else {
			setSkill(new TrackerPythonTwinSkill)
			registerBehavior(new SingleTrackerRole(this.owner), observerADN.get.belief, observerADN.get.platformName,
			computation_location)
			info("Come here : " + detectors.get(MD.cautionLevel))
			//requestAlgorithm(detectors.get(sensitivity.get), "DETECTOR")
			}
		}	
}



	




event BBoxes2DTrackResultToCounter extends BBoxes2DTrackResult{ //@FIXME MEDIUM Nonsens
	
	var observerName : String
	var sensitivity : int
	
	new (t : BBoxes2DTrackMessage, o : String, s: int){
		super(t)
		this.observerName = o
		this.sensitivity=s
	}
}


