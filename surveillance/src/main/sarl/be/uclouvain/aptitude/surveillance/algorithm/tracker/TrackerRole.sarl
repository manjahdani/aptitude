
package be.uclouvain.aptitude.surveillance.algorithm.tracker

import be.uclouvain.aptitude.surveillance.algorithm.LastFrame
import be.uclouvain.aptitude.surveillance.algorithm.util.BBoxe2D
import be.uclouvain.aptitude.surveillance.algorithm.util.HyperParameters
import be.uclouvain.organisation.SignalID
import be.uclouvain.organisation.platform.AddMission
import be.uclouvain.organisation.platform.LeavePlatform
import be.uclouvain.organisation.platform.ObserverRole
import be.uclouvain.python_access.BBoxes2DTrackResult
import be.uclouvain.python_access.messages.BBoxes2DTrackMessage
import io.sarl.core.Behaviors
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpaceSpecification
import java.util.ArrayList
import java.util.LinkedList
import java.util.UUID

/** 
 * @FIXME : IMPROVEMENT : the Hazelcast only need to send the frame number and the ids.  Will it make sens ? 
 * @TODO : Any Observer would transmit the read-only pointer to the memory space
 * that contains the information requested upon approved request from another. 
 * 
 * It does make sens to have a certain window of information in memory and the 
 * other one stored in a database. Therefore, 
 *  the database with a certain window 
 * in situ and otherwise stored in TOLD
 * We need to find a way such that the information is synchronized before potential fusion 
 *
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */
behavior TrackerRole extends ObserverRole {
	
	uses Logging, TrackerPythonTwinCapacity, Behaviors


	val detectors = newArrayList("TinyYOLO", "YOLO") // @FIXME should be given by the Analyst which makes it configurable ?
	
	var totalTrackerTime : double = 0
	var totalDetectorTime : double = 0


	var FrameLimit : int = 100
	
	on LastFrame {
		for (l : listeners.keySet) {
			if (l != this.ID) {
				info("Transmitting to " + l)
			listeners.get(l).emit(this.ID,
				new LastFrame(occurrence.frameNumber,
					occurrence.pred_file_Path,
			occurrence.total_time_detection, occurrence.total_time_tracking))[it.ID == l]}
		}
	}
	@SuppressWarnings("potential_field_synchronization_problem")
	
	
	

	
	on TrackingRequest {
		info("ReactivatingAccess")
		//unregisterBehavior(CompetitiveMultiTrackerRole)
		setSkill(new TrackerPythonTwin)
		registerBehavior(new SingleTrackerRole(this.owner), observerADN.belief, platformName)
		var s = (occurrence.bel.contains("Tiny")) ? 0: 1
		info("Come here detectors.get(s)")
		isMaster.set(false)
		requestAlgorithm(detectors.get(s),"DETECTOR")
	}	

	//@FIXME possibly a reaction of the global behavior observer. We could generalize. 
	on SignalID {
		val dataSource = occurrence.signalID // provider
		// Creation of a communication space between the data source and the role @FIXME is it allowed to use the platform Context?
		val comChannel = platformContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID)
		comChannel.registerStrongParticipant(asEventListener)
		providers.put(dataSource, comChannel)
		debug("Received provider ID sending the missionSpace" + providers.get(dataSource).spaceID.ID)
		platformContext.defaultSpace.emit(this.ID, new AddMission(providers.get(dataSource))) [
			it.ID == dataSource
		]
	}

	
	on LeavePlatform {
		// join(BaseContext.ID, BaseSpace.spaceID.ID)
		info("ObserverTrackerLeaving")
		updateStreamAccess(4)
		// leave(PlatformID)
	}

	on BBoxes2DTrackResult {

		totalDetectorTime += occurrence.bboxes2DTrack.detectionTime
		totalTrackerTime += occurrence.bboxes2DTrack.trackingTime
		
		var tmp : ArrayList<BBoxe2D> = formatConversion(occurrence.bboxes2DTrack)

		
		for (l : listeners.keySet) {
			
			listeners.get(l).emit(this.ID, new TrackingPerception(tmp))[it.ID ==l]
		}
		
		if (occurrence.bboxes2DTrack.frameNumber % 25 ==0){
			info("Processed #" + occurrence.bboxes2DTrack.frameNumber +"frames")
		}
		if (occurrence.bboxes2DTrack.lastFrame || occurrence.bboxes2DTrack.frameNumber > FrameLimit) {

		
			info("Tracking job done... ")
			selfSpace.emit(this.ID, new TrackingTaskOver)
			
			listeners.remove(this.ID)
			
			info("sending the information to " + listeners.keySet)
			for (l : listeners.keySet) {
			listeners.get(l).emit(this.ID,
			new LastFrame(occurrence.bboxes2DTrack.frameNumber, 
				("F:\\Database\\".concat(this.ID.toString) + ".txt"),
			totalDetectorTime, totalTrackerTime))[it.ID == l]
		
			}
			//@FIXME HIGH WEIRD 
			providers.remove(this.ID)
			
			for (p : providers.keySet) {
				if (p != this.ID) {
					providers.get(p).emit(this.ID, new LeavePlatform)[it.ID == p]
				}
			}
		}
	
	}
	
	override startProcessingRole {
		if (isMaster.get) {
			var hyperParatermersToBeTested = new LinkedList<HyperParameters>
			var iter = 0 // @FIXME @FLAG : Low Quick but not robust strategy as if the order of detectors change the system could get confused.
				for (detector : detectors) {
				hyperParatermersToBeTested.add(new HyperParameters(iter))
				info("Come here : " + detector)
				requestAlgorithm(detector, "DETECTOR")
				iter += 1}
				
		registerBehavior(new CompetitiveMultiTrackerRole(this.owner), hyperParatermersToBeTested, this.observerADN,
			TOLDContext, privateTOLDSpace, computation_location)} 
		else {
			setSkill(new TrackerPythonTwin)
			registerBehavior(new SingleTrackerRole(this.owner), observerADN.belief, observerADN.platformName,
			computation_location)
			//info("Come here : " + detectors.get(sensitivity.get))
			//requestAlgorithm(detectors.get(sensitivity.get), "DETECTOR")
			}
		}	
}



	




event BBoxes2DTrackResultToCounter extends BBoxes2DTrackResult{ //@FIXME : Nonsens
	
	var observerName : String
	var sensitivity : int
	
	new (t : BBoxes2DTrackMessage, o : String, s: int){
		super(t)
		this.observerName = o
		this.sensitivity=s
	}
	
}


