package be.uclouvain.aptitude.surveillance.algorithm.tracker.roles

import be.uclouvain.aptitude.surveillance.algorithm.LastFrame
import be.uclouvain.aptitude.surveillance.algorithm.tracker.TrackerPythonTwinCapacity
import be.uclouvain.aptitude.surveillance.algorithm.tracker.TrackerPythonTwinSkill
import be.uclouvain.aptitude.surveillance.algorithm.tracker.events.ResumeTrackingMission
import be.uclouvain.aptitude.surveillance.algorithm.tracker.events.TrackingPerception
import be.uclouvain.aptitude.surveillance.algorithm.util.BBoxe2D
import be.uclouvain.organisation.platform.SensorRole
import be.uclouvain.organisation.platform.events.LeavePlatform
import be.uclouvain.organisation.platform.events.ScenarioInfo
import be.uclouvain.organisation.platform.events.ScenarioInfoRequest
import be.uclouvain.python_access.BBoxes2DTrackResult
import io.sarl.core.Behaviors
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Logging
import java.util.ArrayList
import java.util.UUID
import be.uclouvain.aptitude.surveillance.algorithm.tracker.events.TrackingTaskOver

/** 
 * @FIXME LOW IMPROVEMENT : the Hazelcast only need to send the frame number and the ids.  Will it make sens ? 
 * that contains the information requested upon approved request from another. 
 * 
 * @TODO MEDIUM
 * It does make sens to have a certain window of information in memory and the 
 * other one stored in a database. Therefore, the database with a certain window in situ and otherwise stored in TOLD
 * We need to find a way such that the information is synchronized before potential fusion 
 *
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */
behavior TrackerSignalRole extends SensorRole { // @FIXME VERY VERY VERY HIGH ITS ACTUALLY A SUB-AGENT TRACKER WE ARE BYPASSING THAT.... 
	
	uses Logging, TrackerPythonTwinCapacity, Behaviors, ExternalContextAccess

	var totalTrackerTime : double = 0
	var totalDetectorTime : double = 0

	var frameLimit : int = 1000
	
	on LastFrame {
		info("Transmitting to my listeners" + listeners.keySet)
		for (l : listeners.keySet) {
			emit(listeners.get(l),
				new LastFrame(
					occurrence.frameNumber, 
					occurrence.pred_file_Path, 
					occurrence.total_time_detection,
					occurrence.total_time_tracking, 
					occurrence.observerID))[it.ID==l]
			//listeners.get(l).emit(this.ID,)[it.ID == l]}
		}
	}
	on LeavePlatform {
		// join(BaseContext.ID, BaseSpace.spaceID.ID)
		info("ObserverTrackerLeaving")
		updateStreamAccess(4)
		// leave(PlatformID)
	}

	on BBoxes2DTrackResult {

		totalDetectorTime += occurrence.bboxes2DTrack.detectionTime
		totalTrackerTime += occurrence.bboxes2DTrack.trackingTime
		
		var tmp : ArrayList<BBoxe2D> = formatConversion(occurrence.bboxes2DTrack)

		wake(new TrackingPerception(tmp, occurrence.bboxes2DTrack.frameNumber))[it.ID == this.ID] 
		for (l : listeners.keySet) {
			emit(listeners.get(l), new TrackingPerception(tmp, occurrence.bboxes2DTrack.frameNumber)) [
				it.ID == l
			]		
		}
		
		info("Processed frame #" + occurrence.bboxes2DTrack.frameNumber)
		
		if (occurrence.bboxes2DTrack.lastFrame || occurrence.bboxes2DTrack.frameNumber >= frameLimit) {
			emit(selfSpace, new TrackingTaskOver)
			
			info("Tracking job done... " + "sending the information to " + listeners.keySet)
			
			
			for (l : listeners.keySet) {
				emit(listeners.get(l),
					new LastFrame(
						occurrence.bboxes2DTrack.frameNumber,
					("F:\\Database\\".concat(this.ID.toString) + ".txt"),
					totalDetectorTime, 
					totalTrackerTime,
					ADN.get.ID))[it.ID == l]
			}

		/** 
			listeners.get(l).emit(this.ID,
			new LastFrame(
				occurrence.bboxes2DTrack.frameNumber, 
				("F:\\Database\\".concat(this.ID.toString) + ".txt"),
				totalDetectorTime, 
				totalTrackerTime))[it.ID == l]
			}*/
		}
	
	}
	
	on ResumeTrackingMission {
		info("Resuming mission" + occurrence.missionID +" with "+ occurrence.detector)
		setSkill(new TrackerPythonTwinSkill(ADN.get.belief, ADN.get.platformName,computation_location.get))
		registerBehavior(new SingleTrackerSingleDetectorObserverRole(this.owner))
		info("Come here " + occurrence.detector)
		missionList.get(occurrence.missionID).dynamicAdaptation = false		
		enableDataAcquisition(occurrence.missionID,newArrayList(occurrence.detector), "DETECTOR")
	}

	on ScenarioInfoRequest{
		emit(selfSpace,new ScenarioInfo(organizationContext.get,
			privateOrganizationSpace.get.spaceID.ID,
			computation_location.get
		))
	}
	override processingMissionWithID(mID : UUID) {
		
		if (missionList.get(mID).isDynamicAdaptationEnabled) {
			registerBehavior(new SingleTrackerMultiDetectorObserverRole(owner),this.ADN.get)
		} 
		else {
			warning("Single Tracker processing mID - " + mID)
			setSkill(new TrackerPythonTwinSkill(ADN.get.belief, ADN.get.platformName, computation_location.get))
			registerBehavior(new SingleTrackerSingleDetectorObserverRole(this.owner), ADN.get)
			enableDataAcquisition(mID,"DETECTOR") 
			}
		}

}

