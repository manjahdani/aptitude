/** 
 * 
 */
package be.uclouvain.aptitude.surveillance.algorithm

import be.uclouvain.organisation.events.JoinPlatform
import be.uclouvain.organisation.platform.ObserverRole
import be.uclouvain.organisation.platform.util.HyperParameters
import be.uclouvain.organisation.platform.util.Metadata
import io.sarl.core.AgentSpawned
import io.sarl.core.Behaviors
import io.sarl.core.InnerContextAccess
import io.sarl.core.Logging
import java.util.Collections
import java.util.HashMap
import java.util.TreeMap
import java.util.UUID

/** 
 * @author manjah
 * 
 */
abstract behavior ManagerObserverRole extends ObserverRole {
	uses Logging, Behaviors,InnerContextAccess

	protected val AVAILABLE_INPUT = Collections.synchronizedMap(new TreeMap<String, Metadata>) // @FIXME HIGH should be given by the Analyst which makes it configurable ?
	protected val detector_innerTrackerMap = Collections.synchronizedMap(new HashMap<String, UUID>)
	protected val innerTracker_detectorsMap = Collections.synchronizedMap(new HashMap<UUID, String>)
	protected val innerTracker_ParametersMap = Collections.synchronizedMap(new HashMap<UUID, HyperParameters>)
	protected val internal_externalMap = Collections.synchronizedMap(new HashMap<UUID, UUID>) // First is internal and then external
	
	
	on RoleRegistered {
		info("Received role Registered from " + occurrence.source.ID)
		wake(new JoinPlatform(organizationContext.get, ADN.get.platformName))[it.ID == occurrence.source.ID]
	}

	on AgentSpawned {		
		val mbID = occurrence.agentID
		if (memberAgents.contains(mbID)) {
			info("inner agent - " + mbID)
			wake(new RegisterUnitaryRole)[it.ID == mbID]
		}
	}

}
