package be.uclouvain.aptitude.surveillance.platform

import be.uclouvain.organisation.AddMember
import be.uclouvain.organisation.Identification
import be.uclouvain.organisation.LocalDatabaseRequest
import be.uclouvain.organisation.SignalID
import be.uclouvain.organisation.platform.AddObserver
import be.uclouvain.organisation.platform.AlgorithmJoinPlatform
import be.uclouvain.organisation.platform.ComputationalRessources
import be.uclouvain.organisation.platform.PlatformCapacity
import be.uclouvain.organisation.platform.PlatformRole
import be.uclouvain.organisation.platform.util.MembershipRule
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.InnerContextAccess
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.Schedules
import java.util.Collections
import java.util.HashMap
import java.util.LinkedList
import java.util.UUID

/** 
 * 
 * @TODO
 * @author $Author: manjahdani$
 * @version $0.0.3$
 * @date $11/06/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $organisation$
 * 
 */
behavior SurveillancePlatformRole extends PlatformRole {
	uses InnerContextAccess, ExternalContextAccess, Logging, PlatformCapacity, Schedules, DefaultContextInteractions, Behaviors
	
	protected val participants = Collections.synchronizedMap(new HashMap<String, UUID>) // @FIXME clarify MAP - Lists and so on. clarify also if the variables must be concurrent or not
	val request = Collections.synchronizedList(new LinkedList<String>)
	protected val agentAlgorithm = new HashMap<String, OpenEventSpace>
	
	protected var allocated_ressource : String
	
	@SuppressWarnings("discouraged_occurrence_readonly_use", "potential_field_synchronization_problem")
	on LocalDatabaseRequest {
		info("received a request from " + occurrence.source.ID.toString.substring(0, 5) + " to connect with a database ")
		privateSpacesListeners.get(TOLDID).emit(
			new AddMember(occurrence.source.ID,privateSpacesListeners.get(occurrence.source.ID)))
	}
	
	on ComputationalRessources {
		info("Received Computational Ressources: " + occurrence.client_id + "from ")
		allocated_ressource = occurrence.client_id
	}
	
	on Identification {
		
		info("new participant: " + occurrence.fullName )
		participants.put(occurrence.fullName, occurrence.source.ID)
		wake(new ComputationalRessources(allocated_ressource))[it.ID == occurrence.source.ID]
	}

//	@SuppressWarnings("potential_field_synchronization_problem")
//	on AddAlgorithm {
//		info("recruiting agent algorithm "+ occurrence.algorithmInfo.name + " to join our platform ")
//		agentAlgorithm.get(occurrence.algorithmInfo.task).emit(
//			new AlgorithmJoinPlatform(innerContext, occurrence.missionSpace, occurrence.algorithmInfo.name,
//			occurrence.algorithmInfo.task,
//				occurrence.source.ID))
//	} //Revoir @FIXME Obsolete 
	
	@SuppressWarnings("discouraged_occurrence_readonly_use", "potential_field_synchronization_problem")
	on AddObserver {
		
		var signal = occurrence.signalProvider
		var receiver = occurrence.signalReceiver
		debug("adding observer from " + signal.name + " to " + receiver.name)
		if (RuleManagement(new MembershipRule(occurrence.signalProvider, occurrence.signalReceiver))) {

			debug("\n Partnership of " + signal.name.concat("-").concat(receiver.name) + "legal ")
			synchronized (this) {
				if (!participants.keySet.contains(signal)) {
					if (!request.contains(signal)) {
						request.add(signal.name)
						agentAlgorithm.get(occurrence.signalProvider.task).emit(
							new AlgorithmJoinPlatform(innerContext, signal.name))}
					waitfor(signal.name, occurrence.source.ID)
				} else {
					privateSpacesListeners.get(occurrence.source.ID).emit(
						new SignalID(participants.get(occurrence.signalProvider.name)))
				}
			}
		}
		else {
			debug("\n Partnership of " + signal.name.concat("-").concat(receiver.name) + "is not legal ")
		}
	}
	on AgentAlgorithm {
		debug("encountered : " + occurrence.name + " - " + occurrence.source.ID.toString.substring(0,5))
		agentAlgorithm.put(occurrence.name,occurrence.topic)
		
	}
	synchronized def waitfor(fullName : String, dest : UUID) {
		debug("Waiting " + fullName +" as an original request from -  " + dest.toString.substring(0,5))
		task("waitingfor".concat(fullName).concat(dest.toString)).every(500) [
			if (participants.keySet.contains(fullName)) {
				privateSpacesListeners.get(dest).emit(new SignalID(participants.get(fullName)))[it.ID == dest]
				task("waitingfor".concat(fullName).concat(dest.toString)).cancel
			}
		]
	}
}
