package be.uclouvain.aptitude.surveillance.platform

import be.uclouvain.organisation.events.AddMember
import be.uclouvain.organisation.events.Identification
import be.uclouvain.organisation.events.SignalID
import be.uclouvain.organisation.platform.PlatformCapacity
import be.uclouvain.organisation.platform.PlatformRole
import be.uclouvain.organisation.platform.events.AddObserver
import be.uclouvain.organisation.platform.events.AlgorithmJoinPlatform
import be.uclouvain.organisation.platform.events.ComputationalRessources
import be.uclouvain.organisation.platform.events.LocalDatabaseRequest
import be.uclouvain.organisation.platform.util.MembershipRule
import io.sarl.core.Behaviors
import io.sarl.core.ExternalContextAccess
import io.sarl.core.InnerContextAccess
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.Schedules
import java.util.Collections
import java.util.HashMap
import java.util.LinkedList
import java.util.UUID
import java.util.concurrent.atomic.AtomicReference

/** 
 * 
 * @TODO Comment
 * @author $Author: manjahdani$
 * @version $0.0.3$
 * @date $11/06/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $organisation$
 * 
 */
behavior SurveillancePlatformRole extends PlatformRole {
	uses InnerContextAccess, ExternalContextAccess, Logging, PlatformCapacity, Schedules, Behaviors
	
	protected val participants = Collections.synchronizedMap(new HashMap<String, UUID>) // @FIXME LOW clarify MAP - Lists and so on. clarify also if the variables must be concurrent or not
	val request = Collections.synchronizedList(new LinkedList<String>)
	protected val agentAlgorithm = new HashMap<String, OpenEventSpace>
	
	protected var allocated_ressource = new AtomicReference<String>
	
	
	on LocalDatabaseRequest {
		info("received a request from " + occurrence.source.ID.toString.substring(0, 5) + " to connect with a database ")
		emit(privateSpacesListeners.get(TOLDID),
			new AddMember(occurrence.source.ID,privateSpacesListeners.get(occurrence.source.ID)))
	}
	
	on ComputationalRessources {
		//info("Received computational resources: " + occurrence.client_id + "from ")
		allocated_ressource.set(occurrence.client_id)
	}
	
	on Identification {
		
		debug("new participant: " + occurrence.fullName )
		participants.put(occurrence.fullName, occurrence.source.ID)
		wake(new ComputationalRessources(allocated_ressource.get))[it.ID == occurrence.source.ID]
	}
 
	
	
	on AddObserver {
		
		val signal = occurrence.signalProvider
		val receiver = occurrence.signalReceiver
		debug("adding observer from " + signal.name + " to " + receiver.name)
		if (RuleManagement(new MembershipRule(occurrence.signalProvider, occurrence.signalReceiver))) {

			debug("\n Partnership of " + signal.name.concat("-").concat(receiver.name) + "legal ")
			synchronized (this) {
				if (!participants.containsKey(signal.name)){
					debug("-"+signal.name+"-"+"Algorithm not available" + participants.keySet)
					if (!request.contains(signal)) {
						request.add(signal.name)
						emit(agentAlgorithm.get(occurrence.signalProvider.task),
							new AlgorithmJoinPlatform(innerContext, signal.name))}
					waitfor(occurrence.missionID,signal.name, occurrence.source.ID)
				} else {
					debug("Algorithm is already available" + signal.name)
					emit(privateSpacesListeners.get(occurrence.source.ID),
						new SignalID(occurrence.missionID,participants.get(occurrence.signalProvider.name), occurrence.signalProvider.name))
				}
			}
		}
		else {
			debug("\n Partnership of " + signal.name.concat("-").concat(receiver.name) + "is not legal ")
		}
	}
	on AgentAlgorithm {
		debug("encountered : " + occurrence.name + " - " + occurrence.source.ID.toString.substring(0,5))
		agentAlgorithm.put(occurrence.name,occurrence.topic)
		
	}
	synchronized def waitfor(mID : UUID,fullName : String, dest : UUID) {
		debug("Waiting " + fullName +" as an original request from -  " + dest.toString.substring(0,5))
		task("waitingfor".concat(fullName).concat(dest.toString)).every(500) [
			if (participants.keySet.contains(fullName)) {
				emit(privateSpacesListeners.get(dest),
					new SignalID(mID,participants.get(fullName), fullName)
				)[it.ID == dest]
				task("waitingfor".concat(fullName).concat(dest.toString)).cancel
			}
		]
	}
}
