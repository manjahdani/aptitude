/** 
 * 
 */
package be.uclouvain.aptitude.surveillance.algorithm

import be.uclouvain.aptitude.surveillance.Paraddis
import be.uclouvain.aptitude.surveillance.algorithm.counter.CompetitiveCounterRole
import be.uclouvain.aptitude.surveillance.algorithm.detector.DetectorRole
import be.uclouvain.aptitude.surveillance.algorithm.tracker.TrackerRole
import be.uclouvain.aptitude.surveillance.platform.AgentAlgorithm
import be.uclouvain.aptitude.surveillance.platform.AgentPlatform
import be.uclouvain.organisation.AuthorizationToJoinContext
import be.uclouvain.organisation.platform.AlgorithmJoinPlatform
import be.uclouvain.organisation.told.entity.EntityRole
import be.uclouvain.organisation.told.util.AlgorithmInfo
import io.sarl.core.Behaviors
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.lang.core.AgentContext
import java.util.HashMap
import java.util.UUID

/** 
 * Agent with a set of tasks (Goals) and a model (Belief). 
 * It bases its computations on a Belief, otherwise a model defined by parameters. 
 * Each agent owns the intrinsic desire to achieve its Goal and become better at it. 
 * 
 * Algorithms are firstly classified according to the Goals ((Detector, Tracker, Vehicle Counter, Offense Detectorâ€¦)) and secondly their belief.  
 * 
 * There will exists as many internal space discussions as there is tasks. 
 * 
 * Initially the algorithm, it exists in the realm of TOLD and within a Holon could exist infinite combination of models and parameters. 
 * 
 * @TODO : Must be somewhere else
 * The algorithm becomes operational when joining a Platform. However, the instance does not join another context but rather provide a replicate.
 * The instance may due to local interactions, evolve to be better than to the original at this specific task and Location. 
 * When that happens, the replicate may choose to adapt its belief accordingly and communicate to the original the decision. 
 * If the latest follows, it universally and automatically suggests to child instances the modification. 
 * They now share a new belief. In the case, it does not follow, the replicate will become a new Holon in the realm of TOLD and becomes a distinct entity
 * 
 * 
 * @TODO : The agent may change the belief but not the task. Maybe instead of IFs one should have a more scalable approach by creating specific
 *  What I mean is we should have this algorithm extended and more specific goal-based name. Indeed, it will not be relevant to change the goal for now...  
 * Second thoughts on 13/04. I am not very fond of this logic as it does not respect evolutionnary vision in addition. It does not bring 
 * enough abstraction, bref while it could programming-wise convenient, it will just be a lack of effort in abstraction..)  
 * 
 * @TODO : draw the visual to show the holonic structure (it is not really holonical, actually it is)
 * 
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */
 
@SuppressWarnings("potential_field_synchronization_problem")
agent Algorithm extends Paraddis{
	
	uses Behaviors,Logging, Lifecycle, InnerContextAccess, ExternalContextAccess
	
	var ADN : AlgorithmInfo = null;

	val agentPlatformSpaces = new HashMap<String, OpenEventSpace>
	var subHolons = new HashMap<AgentContext,UUID>
	var openChanel : OpenEventSpace
	
	on Initialize {
		ADN = occurrence.parameters.get(0) as AlgorithmInfo 
		loggingName = this.ID + "-ALGORITHM-" + ADN.name + "-" + ADN.level 
		registerBehavior(new EntityRole(this))
		openChanel = innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID)
		openChanel.registerStrongParticipant(asEventListener)
		
		if (ADN.level == 0) {
			var toSpawn = occurrence.parameters.get(1) as HashMap<UUID, AlgorithmInfo>
			for (e : toSpawn.keySet) {spawnInContextWithID(Algorithm, e, innerContext, toSpawn.get(e).IncrementLevelAndGet)}}
		
		if(ADN.level>1){
			info("atomic agent with task: " + ADN.task + " & belief : " +
				ADN.belief.replace("F:/aptitude/surveillance/src/main/resources/", ""))
			registerBehavior(new AlgorithmEntity(this))
			switch(ADN.task){
				case "COUNTER": {
					registerBehavior(new CompetitiveCounterRole(this), ADN)
				}
				case "TRACKER": {
					registerBehavior(new TrackerRole(this), ADN)
				}
				case "DETECTOR": {
					registerBehavior(new DetectorRole(this), ADN)
				}
			}
		 }
		 else {
			debug("I believe in : " + ADN.name)
		 }
	}
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on AgentPlatform {
		debug("encounters : " + occurrence.name + " agent")
		agentPlatformSpaces.put(occurrence.name, occurrence.topic)
		occurrence.topic.registerStrongParticipant(asEventListener)
		occurrence.topic.emit(this.ID, new AgentAlgorithm(ADN.name, openChanel))
		wake(new AgentPlatform(occurrence.name, occurrence.id, occurrence.topic))[it.ID !== this.ID]
	}
	
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on AlgorithmNeeded  { //
			if (occurrence.name === ADN.name) {
			debug(
				"clones a " + occurrence.task + " named " + occurrence.name + " and belief : " +
					occurrence.belief.replace("F:/aptitude/surveillance/src/main/resources/", "") + " \n to answer the request of " + occurrence.source.ID.toString.substring(0, 5))
			val cloneID = UUID.randomUUID
			subHolons.put(occurrence.contextID, cloneID)
			var cloneADN = ADN.cloneChild
			cloneADN.setID(cloneID) //@FIXME could better code it
			spawnInContextWithID(Algorithm, cloneID, occurrence.contextID, cloneADN) //@FIXME : improper names // Maybe the clone should directly integrate the incrementandLevel
		}}//@FIXME we could have a table of each child, so that we could direct the information to it. 
	on AlgorithmJoinPlatform {
		info("deploys " + ADN.task + " named " + occurrence.name + " performing for " + occurrence.source.ID.toString.substring(0, 5))
		wake(new AlgorithmNeeded(occurrence.contextID, occurrence.name, ADN.task, ADN.belief))
	}

	on AuthorizationToJoinContext {
		info("receives authorisation to join - " + occurrence.source.ID)
		join(occurrence.contextID, occurrence.defaultSpaceID)
	}
}


