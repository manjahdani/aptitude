/** 
 * 
 */
package be.uclouvain.aptitude.surveillance.algorithm

import be.uclouvain.aptitude.surveillance.Paraddis
import be.uclouvain.aptitude.surveillance.platform.AgentAlgorithm
import be.uclouvain.aptitude.surveillance.platform.AgentPlatform
import be.uclouvain.organisation.events.Identification
import be.uclouvain.organisation.events.JoinPlatform
import be.uclouvain.organisation.platform.PlatformOrganizationInfo
import be.uclouvain.organisation.platform.events.AlgorithmJoinPlatform
import be.uclouvain.organisation.told.entity.EntityRole
import be.uclouvain.organisation.told.util.AlgorithmInfo
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.lang.core.Agent
import io.sarl.lang.core.AgentContext
import java.util.HashMap
import java.util.UUID
import java.util.concurrent.atomic.AtomicReference

/** 
 * Agent with a set of tasks (Goals) and a model (Belief). 
 * It bases its computations on a Belief, otherwise a model defined by parameters. 
 * Each agent owns the intrinsic desire to achieve its Goal and become better at it. 
 * 
 * Algorithms are firstly classified according to the Goals ((Detector, Tracker, Vehicle Counter, Offense Detectorâ€¦)) and secondly their belief.  
 * 
 * There will exists as many internal space discussions as there is tasks. 
 * 
 * Initially the algorithm, it exists in the realm of TOLD and within a Holon could exist infinite combination of models and parameters. 
 * 
 * @TODO : Must be somewhere else
 * The algorithm becomes operational when joining a Platform. However, the instance does not join another context but rather provide a replicate.
 * The instance may due to local interactions, evolve to be better than to the original at this specific task and Location. 
 * When that happens, the replicate may choose to adapt its belief accordingly and communicate to the original the decision. 
 * If the latest follows, it universally and automatically suggests to child instances the modification. 
 * They now share a new belief. In the case, it does not follow, the replicate will become a new Holon in the realm of TOLD and becomes a distinct entity
 * 
 * 
 * @TODO : The agent may change the belief but not the task. Maybe instead of IFs one should have a more scalable approach by creating specific
 *  What I mean is we should have this algorithm extended and more specific goal-based name. Indeed, it will not be relevant to change the goal for now...  
 * Second thoughts on 13/04. I am not very fond of this logic as it does not respect evolutionnary vision in addition. It does not bring 
 * enough abstraction, bref while it could programming-wise convenient, it will just be a lack of effort in abstraction..)  
 * 
 * @FIXME MEDIUM CLARIFY THAT ALGORITHM ARE IMMUTABLE, THUS THEY MUST CLONE AND THAT NEW COPY CAN CHANGE
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */
 

agent Algorithm extends Paraddis{
	
	uses Behaviors,Logging, Lifecycle, InnerContextAccess, ExternalContextAccess,DefaultContextInteractions
	
	protected val ADN  = new AtomicReference<AlgorithmInfo>

	val agentPlatformSpaces = new HashMap<String, OpenEventSpace>
	var subHolons = new HashMap<AgentContext, UUID>
	var openChanel = new AtomicReference<OpenEventSpace>
	val INIT_TASKS = new HashMap<String, Class<? extends Agent>>

	on Initialize {
		INIT_TASKS.putAll(occurrence.parameters.get(0) as HashMap<String, Class<? extends Agent>>)
		ADN.set(occurrence.parameters.get(1) as AlgorithmInfo) 
		loggingName = this.ID + "-" + ADN.get.task+"-" + ADN.get.name + "-" + ADN.get.level 
		registerBehavior(new EntityRole(this))
		openChanel.set(innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID))
		openChanel.get.registerStrongParticipant(asEventListener)
		debug("atomic agent with task: " + ADN.get.task + " & belief : " + ADN.get.belief.replace("F:/aptitude/surveillance/src/main/resources/", ""))
		if (ADN.get.level == 0) {
			registerBehavior(new ManagerAlgorithmRole(this), INIT_TASKS, ADN.get)
			var toSpawn = occurrence.parameters.get(2) as HashMap<UUID, AlgorithmInfo>
			for (e : toSpawn.keySet) {
				spawnInContextWithID(Algorithm, e, innerContext, INIT_TASKS,toSpawn.get(e))
			}
		}
		
		
		if(ADN.get.level>1){
			
			registerBehavior(new AlgorithmEntity(this))
			
		 }
	}

	on AlgorithmJoinPlatform {
		info("deploys " + ADN.get.task + " named " + occurrence.name + " performing in platform " +
			occurrence.source.ID)
		// wake(new AlgorithmNeeded(occurrence.contextID, occurrence.name, ADN.get.task, ADN.get.belief))
	}
	on AgentPlatform {
		debug("encounters : " + occurrence.name + " agent")
		agentPlatformSpaces.put(occurrence.name, occurrence.topic)
		occurrence.topic.registerStrongParticipant(asEventListener)
		emit(occurrence.topic, new AgentAlgorithm(ADN.get.name, openChanel.get))
		wake(new AgentPlatform(occurrence.name, occurrence.id, occurrence.topic))[it.ID !== this.ID]
	}
	
	on JoinPlatform {
		info("received join platfom " + occurrence.contextID.ID)
		join(occurrence.contextID.ID,occurrence.contextID.defaultSpace.spaceID.ID)
	}
	
	
	on AlgorithmNeeded  { //
			if (occurrence.name === ADN.get.name) {
			info(
				"clones name " +occurrence.name + " and belief : " +" \n to answer the request of " + occurrence.source.ID)
		
			subHolons.put(occurrence.contextID, occurrence.agentID)

			spawnInContextWithID(
				INIT_TASKS.get(ADN.get.task), 
				occurrence.agentID, 
				occurrence.contextID,
				INIT_TASKS,
				ADN.get.cloneChildWithID(occurrence.agentID))
		}
				
			else{
				debug("Received a request but transmit to the lowerLevel")
				wake(new AlgorithmNeeded(occurrence.contextID,occurrence.name,occurrence.agentID))[it.ID !== this.ID]
			}
	}

	
	on PlatformOrganizationInfo {
		
		info("Algorithm joined - " + occurrence.context.ID)
		emit(
			occurrence.context.getOrCreateSpaceWithID(
				OpenEventSpaceSpecification,occurrence.privateCommunicationChannelID),
			new Identification(ADN.get.name)
		)
	}

}


