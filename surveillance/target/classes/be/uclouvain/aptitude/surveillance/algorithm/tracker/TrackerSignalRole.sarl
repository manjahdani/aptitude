package be.uclouvain.aptitude.surveillance.algorithm.tracker

import be.uclouvain.aptitude.surveillance.algorithm.LastFrame
import be.uclouvain.aptitude.surveillance.algorithm.util.BBoxe2D
import be.uclouvain.organisation.platform.SensorRole
import be.uclouvain.organisation.platform.events.LeavePlatform
import be.uclouvain.organisation.platform.events.RemoveMission
import be.uclouvain.organisation.platform.util.HyperParameters
import be.uclouvain.python_access.BBoxes2DTrackResult
import be.uclouvain.python_access.messages.BBoxes2DTrackMessage
import io.sarl.core.Behaviors
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Logging
import java.util.ArrayList
import java.util.LinkedList
import java.util.UUID
import be.uclouvain.organisation.platform.events.ScenarioInfoRequest
import be.uclouvain.organisation.platform.events.ScenarioInfo

/** 
 * @FIXME LOW IMPROVEMENT : the Hazelcast only need to send the frame number and the ids.  Will it make sens ? 
 * that contains the information requested upon approved request from another. 
 * 
 * @FIXME MEDIUM
 * It does make sens to have a certain window of information in memory and the 
 * other one stored in a database. Therefore, the database with a certain window in situ and otherwise stored in TOLD
 * We need to find a way such that the information is synchronized before potential fusion 
 *
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */
behavior TrackerSignalRole extends SensorRole { // @FIXME VERY VERY VERY HIGH ITS ACTUALLY A SUB-AGENT TRACKER WE ARE BYPASSING THAT.... 
	
	uses Logging, TrackerPythonTwinCapacity, Behaviors, ExternalContextAccess


	val detectors = newArrayList("YOLO", "YOLO-COCO") // @FIXME HIGH should be given by the Analyst which makes it configurable ?
	
	var totalTrackerTime : double = 0
	var totalDetectorTime : double = 0


	var frameLimit : int = 500
	
	on LastFrame {
		debug("Transmitting to my listeners" + listeners.keySet)
		for (l : listeners.keySet) {
			emit(listeners.get(l),
				new LastFrame(
					occurrence.frameNumber, 
					occurrence.pred_file_Path, 
					occurrence.total_time_detection,
					occurrence.total_time_tracking, 
					occurrence.observerID))[it.ID==l]
			//listeners.get(l).emit(this.ID,)[it.ID == l]}
		}
	}
	
	on RemoveMission{
		warning("Received a request to remove a mission COMMENTED BEHAVIOR")
		//emit(providers.get(occurrence.expertID),new PauseMission)[it.ID==occurrence.expertID]
	}
	
	on LeavePlatform {
		// join(BaseContext.ID, BaseSpace.spaceID.ID)
		info("ObserverTrackerLeaving")
		updateStreamAccess(4)
		// leave(PlatformID)
	}

	on BBoxes2DTrackResult {

		totalDetectorTime += occurrence.bboxes2DTrack.detectionTime
		totalTrackerTime += occurrence.bboxes2DTrack.trackingTime
		
		var tmp : ArrayList<BBoxe2D> = formatConversion(occurrence.bboxes2DTrack)

		wake(new TrackingPerception(tmp, occurrence.bboxes2DTrack.frameNumber))[it.ID == this.ID] 
		for (l : listeners.keySet) {
			emit(listeners.get(l), new TrackingPerception(tmp, occurrence.bboxes2DTrack.frameNumber)) [
				it.ID == l
			]		
		}
		
		if (occurrence.bboxes2DTrack.frameNumber % 250 ==0){
			info("Processed #" + occurrence.bboxes2DTrack.frameNumber +"frames")
		}
		if (occurrence.bboxes2DTrack.lastFrame || occurrence.bboxes2DTrack.frameNumber > frameLimit) {
			emit(selfSpace, new TrackingTaskOver)
			
			debug("Tracking job done... " + "sending the information to " + listeners.keySet)
			
			for (l : listeners.keySet) {
				emit(listeners.get(l),
					new LastFrame(
						occurrence.bboxes2DTrack.frameNumber,
					("F:\\Database\\".concat(this.ID.toString) + ".txt"),
					totalDetectorTime, 
					totalTrackerTime,
					ADN.get.ID))[it.ID == l]
			}

		/** 
			listeners.get(l).emit(this.ID,
			new LastFrame(
				occurrence.bboxes2DTrack.frameNumber, 
				("F:\\Database\\".concat(this.ID.toString) + ".txt"),
				totalDetectorTime, 
				totalTrackerTime))[it.ID == l]
			}*/
		}
	
	}
	
	on ResumeTrackingMission {
		info("Resuming my mission with "+ occurrence.detector)
		setSkill(new TrackerPythonTwinSkill)
		registerBehavior(new SingleTrackerRole(this.owner), ADN.get.belief, ADN.get.platformName, computation_location)
		info("Come here " + occurrence.detector)
		missionList.get(occurrence.missionID).dynamicAdaptation = false		
		enableDataAcquisition(occurrence.missionID,newArrayList(occurrence.detector), "DETECTOR")
	}

	on ScenarioInfoRequest{
		emit(selfSpace,new ScenarioInfo(organizationContext.get,
			privateOrganizationSpace.get.spaceID.ID,
			computation_location.get
		))
	}
	override processingMissionWithID(mID : UUID) {
		
		if (missionList.get(mID).isDynamicAdaptationEnabled) {
			
			var hyperParatermersToBeTested = new LinkedList<HyperParameters>
			var iter = 0 // @FIXME MEDIUM Quick but not robust strategy as if the order of detectors change the system could get confused.
			
			for (d : detectors) {
				hyperParatermersToBeTested.add(new HyperParameters(iter,false))
				iter += 1
			}
			
			registerBehavior(new MultiTrackerRole(owner), hyperParatermersToBeTested, this.ADN,
				computation_location, detectors)

			
				
		} 
		else {
			setSkill(new TrackerPythonTwinSkill)
			registerBehavior(new SingleTrackerRole(this.owner), ADN.get.belief, ADN.get.platformName,
			computation_location)
			
			enableDataAcquisition(mID, newArrayList(detectors.get(missionList.get(mID).cautionLevel)), "DETECTOR")
			}
		}
	
	def startRole {
		warning("TODO: auto-generated method stub")
	}
}



	




event BBoxes2DTrackResultToCounter extends BBoxes2DTrackResult{ //@FIXME MEDIUM Nonsens
	
	var observerName : String
	var sensitivity : int
	
	new (t : BBoxes2DTrackMessage, o : String, s: int){
		super(t)
		this.observerName = o
		this.sensitivity=s
	}
}


