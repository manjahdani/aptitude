/** 
 * 
 */
package be.uclouvain.aptitude.surveillance.algorithm.tracker.roles

import be.uclouvain.aptitude.surveillance.algorithm.PythonTwinObserverRole
import be.uclouvain.aptitude.surveillance.algorithm.tracker.TrackerPythonTwinCapacity
import be.uclouvain.python_access.BBoxes2DResult
import be.uclouvain.python_access.PartnerTrackingFound
import io.sarl.core.Initialize
import be.uclouvain.organisation.platform.events.ScenarioInfoRequest
import io.sarl.core.ExternalContextAccess
import be.uclouvain.organisation.platform.events.ScenarioInfo
import io.sarl.core.Logging

/** 
 * @author manjah
 * 
 */
//val dynamicTrackingMemory = Collections.synchronizedList(new LinkedList<ArrayList<BBoxes2D>>)


behavior SingleTrackerObserverRole extends PythonTwinObserverRole {
	
	uses TrackerPythonTwinCapacity,Logging, ExternalContextAccess

	on PartnerTrackingFound {
		//info("Tracking Partner found: " +  occurrence.partnerName)
	}

	on Initialize {
		info("Multi-tracker role started.")
		emit(selfSpace, new ScenarioInfoRequest)

	}

	on ScenarioInfo {
		assert occurrence.client_id !== null, "Received computatation_location null"
		computation_location.set(occurrence.client_id)
		updateContextInfo(occurrence.organizationContext, occurrence.privateCommunicationChannelID)
		checkList.replace("context", true)
		checkList.replace("computation_location", true)
	}

	on BBoxes2DResult {
		
		/**
		if (occurrence.providerName =="BACKGROUND") {
			warning(
				"Received results of frame #" + occurrence.bboxes2D.frameNumber + "\n x=" + occurrence.bboxes2D.bboxes.toString
			)

		}*/
		Signal2Perception(occurrence.bboxes2D)
	}
	
	def startRole {
		warning("TODO: auto-generated method stub")
	}
	
}
