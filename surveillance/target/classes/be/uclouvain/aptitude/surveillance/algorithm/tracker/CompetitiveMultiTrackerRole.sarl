/** 
 * 
 */
package be.uclouvain.aptitude.surveillance.algorithm.tracker

import be.uclouvain.aptitude.surveillance.algorithm.Algorithm
import be.uclouvain.aptitude.surveillance.algorithm.LastFrame
import be.uclouvain.aptitude.surveillance.algorithm.util.HyperParameters
import be.uclouvain.organisation.events.AddMember
import be.uclouvain.organisation.events.SignalID
import be.uclouvain.organisation.platform.events.AddMission
import be.uclouvain.organisation.platform.events.ComputationalRessources
import be.uclouvain.organisation.platform.events.HyperParametersRequest
import be.uclouvain.organisation.platform.events.ProcessingHyperParameters
import be.uclouvain.organisation.platform.events.RemoveMission
import be.uclouvain.organisation.told.util.AlgorithmInfo
import be.uclouvain.python_access.BBoxes2DResult
import io.sarl.core.Behaviors
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.core.Schedules
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.LinkedList
import java.util.UUID

/** 
 * @author manjah
 * 
 */
 
behavior CompetitiveMultiTrackerRole {
	uses Logging, Lifecycle, InnerContextAccess, Schedules , Behaviors, ExternalContextAccess
	
	var detectors : ArrayList<String>  // @FIXME HIGH LOGICIEL PARAMETERS ?
	
	protected val sub_processes = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the role and data providers
	protected val detector_innerTrackerMap = Collections.synchronizedMap(new HashMap<String, UUID>)
	protected val innerTracker_detectorsMap = Collections.synchronizedMap(new HashMap<UUID, String>)
	protected val innerTracker_ParametersMap = Collections.synchronizedMap(new HashMap<UUID, HyperParameters>)
	protected var computation_Location : String

	protected val activeProviders = Collections.synchronizedMap(new HashMap<String, UUID>) // Detector and its ID

	on Initialize {
		info("Competitive multi-tracker role started.")

		var hyperParametersToBeTested : LinkedList<HyperParameters>
		var observerADN : AlgorithmInfo
		try {hyperParametersToBeTested = occurrence.parameters.get(0) as LinkedList<HyperParameters>}
		catch (e : ClassCastException) {
			warning("Could not cast Initialise parameters 0 to a LinkedList")
		}
		try {
			observerADN = occurrence.parameters.get(1) as AlgorithmInfo
		} 
		catch (e : ClassCastException) {
			warning("Could not cast Initialise parameters 1 to AlgorithmInfo")
		}

		
		computation_Location = occurrence.parameters.get(4).toString
		detectors = occurrence.parameters.get(5) as ArrayList<String>
		
		for (param : hyperParametersToBeTested) {
		var cloneID = UUID.randomUUID
		innerTracker_ParametersMap.put(cloneID, param)	
		spawnInContextWithID(Algorithm, cloneID, innerContext, observerADN.cloneChild(cloneID)) // Spawn a sub-process specialised using the hyperParameters s
		var comSpace : OpenEventSpace = innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID) // An internal space to communicate with other roles.
		comSpace.registerStrongParticipant(asEventListener)
		sub_processes.put(cloneID, comSpace)
		detector_innerTrackerMap.put(detectors.get(param.sensitivity), cloneID)
		innerTracker_detectorsMap.put(cloneID,detectors.get(param.sensitivity))
		}

		task("a").in(400) [
			for (cloneID : sub_processes.keySet) {
				wake(new AddMission(sub_processes.get(cloneID)))[it.ID == cloneID]
				wake(new ComputationalRessources(computation_Location))[it.ID == cloneID]
			}
			task("a").cancel
		] //@FIXME HIGH something to do with synchronization
		
		
		task("b").in(500) [
		for (cloneID : sub_processes.keySet)
		{
			emit(privateTOLDSpace, new AddMember(cloneID, sub_processes.get(cloneID)))[it.ID == TOLDContext.ID]
		}
		task("b").cancel
		]
		
	}

	
	on TrackingRequest {
		debug("Reactivating Access - " + occurrence.competitorID + " - " + innerTracker_detectorsMap.get(occurrence.competitorID))
		
		if (innerTracker_detectorsMap.get(occurrence.competitorID) == "YOLO-COCO"){
			info("We are more in a horizontal view")
		}
		else if (innerTracker_detectorsMap.get(occurrence.competitorID) == "YOLO") {
			info("We are in a vertical view")
		}
		wake(new ResumeTrackingMission(innerTracker_detectorsMap.get(occurrence.competitorID)))[it.ID==this.ID]
		
	}	
	on HyperParametersRequest {
	
		var providerID = occurrence.source.ID
		// We decide that derived role handles the parameters request of inner-agents.
		
		if (getMemberAgents.contains(providerID)) {
			var param = innerTracker_ParametersMap.get(providerID)
			debug("Inner tracker request from -" + providerID.toString.substring(0, 5) + " sends  s :" + param.sensitivity)
			
			emit(sub_processes.get(providerID), new ProcessingHyperParameters(param.sensitivity, false)) [
				it.ID == providerID
			]
		}
	}
	
	on SignalID{
		activeProviders.put(occurrence.name,occurrence.signalID)
	}
	
	on LastFrame {
		
		debug("detectorToRemove = " + innerTracker_detectorsMap.get(occurrence.source.ID))
		var detectorToRemove = innerTracker_detectorsMap.get(occurrence.source.ID)
		var id = activeProviders.get(detectorToRemove)
		wake(new RemoveMission(id))[it.ID==this.ID]
	}

	on BBoxes2DResult {
		
		if(occurrence.bboxes2D.frameNumber <5){
		debug("Sending results of frame #" + occurrence.bboxes2D.frameNumber + 
			" from " + occurrence.providerName + " to " + detector_innerTrackerMap.get(occurrence.providerName))
		}
		// We send to the sub-process meant to analyse the data of the provider. 
		// For example, agent 1 process the data sent from detector A. 
		wake(new BBoxes2DResult(occurrence.bboxes2D))[it.ID == detector_innerTrackerMap.get(occurrence.providerName)] 
	}
}

event ResumeTrackingMission {
	val detector : String

	new(d : String) {
		this.detector = d
	}
}
