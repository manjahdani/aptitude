
package be.uclouvain.aptitude.surveillance.algorithm.tracker

import be.uclouvain.aptitude.surveillance.algorithm.LastFrame
import be.uclouvain.aptitude.surveillance.algorithm.detector.RestartDetector
import be.uclouvain.aptitude.surveillance.algorithm.util.BBoxe2D
import be.uclouvain.aptitude.surveillance.algorithm.util.HyperParameters
import be.uclouvain.organisation.SignalID
import be.uclouvain.organisation.platform.AddMission
import be.uclouvain.organisation.platform.HyperParametersRequest
import be.uclouvain.organisation.platform.LeavePlatform
import be.uclouvain.organisation.platform.ObserverRole
import be.uclouvain.organisation.platform.ProcessingHyperParameters
import be.uclouvain.python_access.BBoxes2DTrackResult
import be.uclouvain.python_access.messages.BBoxes2DTrackMessage
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpaceSpecification
import java.util.ArrayList
import java.util.LinkedList
import java.util.UUID

/** 
 * @FIXME : IMPROVEMENT : the Hazelcast only need to send the frame number and the ids.  Will it make sens ? 
 * @TODO : Any Observer would transmit the read-only pointer to the memory space
 * that contains the information requested upon approved request from another. 
 * 
 * It does make sens to have a certain window of information in memory and the 
 * other one stored in a database. Therefore, 
 *  the database with a certain window 
 * in situ and otherwise stored in TOLD
 * We need to find a way such that the information is synchronized before potential fusion 
 *
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */
behavior TrackerRole extends ObserverRole {
	
	uses Logging, TrackerPythonTwinCapacity, DefaultContextInteractions, Lifecycle, Behaviors


	val detectors = newArrayList("TinyYOLO", "YOLO") // @FIXME should be given by the Analyst which makes it configurable ?
	
	var totalTrackerTime : double = 0
	var totalDetectorTime : double = 0


	var FrameLimit : int
	
	on LastFrame {
		info("Received last frame " + listeners)
		
		for (listenersSpace : listeners.values) {
			
			listenersSpace.emit(this.ID,
					new LastFrame(
						occurrence.frameNumber, 
						("F:\\Database\\".concat(this.ID.toString) + ".txt"), 
						totalDetectorTime,
						totalTrackerTime)) [it.UUID !== this.ID]
						
						}
	   }
	@SuppressWarnings("potential_field_synchronization_problem")
	
	
	on ProcessingHyperParameters {
		
		sensitivity = occurrence.s
		
		if (occurrence.OptimalSearchEnabled) {
			var hyperParatermersToBeTested = new LinkedList<HyperParameters>
			var iter = 0 // @FIXME @FLAG : Low Quick but not robust strategy as if the order of detectors change the system could get confused. 
			for (detector : detectors) {
				hyperParatermersToBeTested.add(new HyperParameters(iter))
				info("Come here : " + detector)
				requestAlgorithm(detector,"DETECTOR")
				iter += 1
			}
			
			registerBehavior(new CompetitiveMultiTrackerRole(this.owner), hyperParatermersToBeTested, this.observerADN)
		}
		else {
		setSkill(new TrackerPythonTwin)
		registerBehavior(new SingleTrackerRole(this.owner), observerADN.belief, observerADN.platformName)
		info("Come here : " + detectors.get(sensitivity))
		
		if(isMaster){
			requestAlgorithm(detectors.get(sensitivity),"DETECTOR")
		}
	}
 }
	on HyperParametersRequest {
		
		if (providers.keySet.contains(occurrence.source.UUID)) { // That means that he is single tracker. No subprocesses
		var providerID = occurrence.source.UUID
		info("received sensitivity request from -" + providerID.toString.substring(0, 5) +
				" .... \n  sending the following sensitivity" + sensitivity)

		providers.get(providerID).emit(this.ID, new ProcessingHyperParameters(sensitivity, isMaster)) [
			it.UUID == providerID
		]}
	}
	

	on TrackingRequest {
		// info("ReactivatingAccess")
		//unregisterBehavior(CompetitiveMultiTrackerRole)
		setSkill(new TrackerPythonTwin)
		registerBehavior(new SingleTrackerRole(this.owner), observerADN.belief, platformName)
		var s = (occurrence.bel.contains("Tiny")) ? 0: 1
		info("Come here detectors.get(s)")
		emit(new RestartDetector(detectors.get(s)))
	}	

	//@FIXME possibly a reaction of the global behavior observer. We could generalize. 
	on SignalID {
		val dataSource = occurrence.signalID // provider
		// Creation of a communication space between the data source and the role @FIXME is it allowed to use the platform Context?
		val comChannel = platformContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID)
		comChannel.register(asEventListener)
		providers.put(dataSource, comChannel)
		info("\n received the provider ID \n sending the missionSpace" + providers.get(dataSource).spaceID.ID)
		platformContext.defaultSpace.emit(this.ID, new AddMission(providers.get(dataSource))) [
			it.UUID == dataSource
		]
	}

	
	on LeavePlatform {
		// join(BaseContext.ID, BaseSpace.spaceID.ID)
		info("ObserverTrackerLeaving")
		updateStreamAccess(4)
		// leave(PlatformID)
	}

	on BBoxes2DTrackResult {

		totalDetectorTime += occurrence.bboxes2DTrack.detectionTime
		totalTrackerTime += occurrence.bboxes2DTrack.trackingTime
		
		var tmp : ArrayList<BBoxe2D> = formatConversion(occurrence.bboxes2DTrack)

		//dynamicTrackingMemory.add(frameNumber,tmp)
		for (l : listeners.values) {
			l.emit(this.ID, new TrackingPerception(tmp))[it != me]
		}
		
		if (occurrence.bboxes2DTrack.frameNumber % 10 ==0){
			info("Processed %d frames", occurrence.bboxes2DTrack.frameNumber)
		}
		if (occurrence.bboxes2DTrack.lastFrame || occurrence.bboxes2DTrack.frameNumber > FrameLimit) {

			emit(new LastFrame(occurrence.bboxes2DTrack.frameNumber))[it.UUID == this.ID]
			for (p : providers.keySet) {
				providers.get(p).emit(this.ID, new LeavePlatform)[it.UUID == p]
			}
			killMe
		}
	}
	

}


event BBoxes2DTrackResultToCounter extends BBoxes2DTrackResult{ //@FIXME : Nonsens
	
	var observerName : String
	var sensitivity : int
	
	new (t : BBoxes2DTrackMessage, o : String, s: int){
		super(t)
		this.observerName = o
		this.sensitivity=s
	}
	
}

/** 
 * on ProcessingHyperParameters {
 * 
 * //@FIXME We could totally generalize that. 
 * sensitivity= new LinkedList(occurrence.s)
 * if(sensitivity.size==1)
 * {
 * LastFrame = 50
 * task("waitforConfig").every(500) [
 * if (jsonConfig !== null) {
 * setSkill(new TrackerPythonTwin)
 * ActivateAccess(jsonConfig)
 * task("waitforConfig").cancel
 * }
 * ]
 * // val ObserverName = availableObservers.get(intensityMap.get(sensitivity.get))
 * val DetectorName = availableObservers.get(sensitivity.get(0))
 * //info("Come here : " + DetectorName)	
 * privatePlatformSpace.emit(this.ID,
 * new AddObserver(new AlgorithmInfo(DetectorName, "DETECTOR"),
 * new AlgorithmInfo(observerADN.name, "TRACKER")))[it.UUID == platformContext.ID]
 * }
 * else {
 * for(s : sensitivity)
 * {
 * info("Come here : " + observerADN.name.concat(s.toString))
 * privatePlatformSpace.emit(this.ID, new AddObserver(new AlgorithmInfo(observerADN.name, "TRACKER", observerADN.level+1),
 * new AlgorithmInfo(observerADN.name, "TRACKER", observerADN.level))) [
 * it.UUID == platformContext.ID
 * ]
 * }//@FIXME Probably the trackers will accumulate in platforms. Remember to deal with that by removing if one ends its duty.  
 * }
 * }
 */
 
 

/* 
 * synchronized (this)
 * try {
 * gt.write(
 * (frameNumber + 1).toString + "," + globalID.toString + "," + X.intValue.toString + "," +
 * Y.intValue.toString + "," + W.intValue.toString + "," +
 * H.intValue.toString + "," + 
 * "-1" +
 * "," + "-1" + "," + "-1" + "," + "-1" + "\n")
 * }
 * catch (e:NullPointerException)
 * {
 * info("NullPointerException from " + occurrence.source.UUID)
 * }
 */

