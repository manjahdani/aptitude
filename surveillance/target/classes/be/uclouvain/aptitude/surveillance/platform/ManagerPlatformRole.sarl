/** 
 * 
 */
package be.uclouvain.aptitude.surveillance.platform

import be.uclouvain.organisation.events.JoinPlatform
import be.uclouvain.organisation.platform.PlatformRole
import be.uclouvain.organisation.platform.events.ComputationalRessources
import be.uclouvain.organisation.platform.events.LocalDatabaseRequest
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.Schedules
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.UUID
import java.util.concurrent.ConcurrentLinkedQueue
import io.sarl.core.ExternalContextAccess

/** 
 * @TODO To complete
 * 
 */
behavior ManagerPlatformRole extends PlatformRole {
	
	uses DefaultContextInteractions, Schedules, Logging, Behaviors,ExternalContextAccess


	
	val subPlatformsOpenSpaces = new HashMap<String, OpenEventSpace> // TreeMap of the sub-worlds composing the world. It is used to be able to communicate with other worlds
	val subPlatformsIDs = new HashMap<UUID,String>
	
	val RESSOURCES_AVAILABLE = new ConcurrentLinkedQueue<String>
	val ALLOCATED_RESSOURCES = Collections.synchronizedMap(new HashMap<UUID,String>)

	on Initialize {
		RESSOURCES_AVAILABLE.addAll(occurrence.parameters.get(1) as ArrayList<String>)
	}
	
	on AgentPlatform {
		var a = RESSOURCES_AVAILABLE.poll
		info("Meeting agent: "+ occurrence.name + " allocating resources number - " + a)
		subPlatformsIDs.put(occurrence.id, occurrence.name)
		ALLOCATED_RESSOURCES.put(occurrence.id,a)
		wake(new ComputationalRessources(a))[it.ID== occurrence.source.ID]	
		if (!subPlatformsOpenSpaces.containsKey(occurrence.name)) {
			subPlatformsOpenSpaces.put(occurrence.name, occurrence.topic)
			emit(new AgentPlatform(occurrence.name, occurrence.id, occurrence.topic))[it.ID != this.ID]
		}
	} // It is okay to send it to the Universe Context as it is omniscient

	on LocalDatabaseRequest {
		task("wait4TOLD".concat(occurrence.source.ID.toString)).every(100) [
				if (TOLDID.get !== null) {
					emit(
						new JoinPlatform(occurrence.contextID, subPlatformsIDs.get(occurrence.source.ID))) 
						[it.ID == TOLDID.get] // privateSpacesListeners.get(TOLDID).
					task("wait4TOLD".concat(occurrence.source.ID.toString)).cancel
					}
			]
		}
}
