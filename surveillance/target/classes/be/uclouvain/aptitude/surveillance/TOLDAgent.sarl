/** 
 * 
 */
package be.uclouvain.aptitude.surveillance

import be.uclouvain.aptitude.surveillance.algorithm.Algorithm
import be.uclouvain.aptitude.surveillance.platform.AgentPlatform
import be.uclouvain.organisation.events.JoinPlatform
import be.uclouvain.organisation.told.AccessDatabaseCapacity
import be.uclouvain.organisation.told.TOLDRole
import be.uclouvain.organisation.told.util.AlgorithmInfo
import io.sarl.core.Behaviors
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import java.util.ArrayList
import java.util.HashMap
import java.util.UUID
import io.sarl.core.ExternalContextAccess

/** 
 * 
 * The agent TOLD keeps record of current and past knowledge. 
 * The size of the database is a parameter and therefore we could have local TOLD 
 * that communicates to a higher TOLD itself communicating to a bigger database. 
 * The TOLD agent creates within its context spaces, as many agents as there are different tasks. 
 * Therefore a space for Detectors, Trackers, Vehicle Counter and broadly speaking each class of algorithms.    
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $31/03/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 */
 
  
agent TOLDAgent extends Paraddis {
	
	uses Logging, Lifecycle, InnerContextAccess, Behaviors, ExternalContextAccess

 	//val INIT_TASKS : ArrayList<String> = newArrayList() // @parameters
	
	var config : TOLDConfig
	val agentPlatformSpaces = new HashMap<String, OpenEventSpace> 
	var S : VirtualDatabaseSkill
	
	
	on Initialize {
		
		info("ready to share my stored knowledge.")
		
		S = setSkill(new VirtualDatabaseSkill, AccessDatabaseCapacity)
		registerBehavior(new TOLDRole(this))
		config = occurrence.parameters.get(0) as TOLDConfig
		loggingName = this.ID + "-TOLD" + "-" + config.level
		info("ready to share my stored knowledge.")
		var registeredAlgorithms : HashMap<UUID, AlgorithmInfo> = new HashMap(S.database.filter [ p1, p2 |
			p2 instanceof AlgorithmInfo
		])
		for (t : config.init_tasks) {
			spawnInContext(Algorithm, innerContext, new AlgorithmInfo(t, "none", t),
				new HashMap(registeredAlgorithms.filter[p1, p2|p2.task == t]))
		}
	}
	

	
	on AgentPlatform {
		info("encounters " + occurrence.name + " agent platform")
		agentPlatformSpaces.put(occurrence.name, occurrence.topic)
		occurrence.topic.registerStrongParticipant(asEventListener)
		wake(new AgentPlatform(occurrence.name, occurrence.id, occurrence.topic))[it.ID !== this.ID]
	}
	
	on JoinPlatform {
		info("joins organisation - " + occurrence.contextID.toString.substring(0,5))
		val randomID = UUID.randomUUID
		var holonConfig = config.addSubTOLD(new TOLDConfig(config.level + 1, occurrence.location, innerContext, new ArrayList<String>), randomID)
		spawnInContextWithID(TOLDAgent, randomID, getContext(occurrence.contextID), holonConfig)
	}
	
}



