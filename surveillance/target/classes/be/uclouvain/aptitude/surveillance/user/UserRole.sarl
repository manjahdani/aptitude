/** 

 */
package be.uclouvain.aptitude.surveillance.user

import UDPMessages.CharacterData
import UDPMessages.UDP_Message_RequestSpawn
import UDPMessages.UDP_Message_RequestWithdraw
import be.uclouvain.aptitude.surveillance.Expert
import be.uclouvain.organisation.HolonicParentInfo
import be.uclouvain.organisation.interactivity.element.ElementInformation
import be.uclouvain.organisation.interactivity.element.ElementRole
import be.uclouvain.organisation.platform.AuthorizedMission
import be.uclouvain.organisation.platform.NewMission
import be.uclouvain.organisation.platform.StopMission
import be.uclouvain.organisation.platform.util.MissionData
import io.sarl.core.Behaviors
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import java.util.HashMap
import java.util.LinkedList
import java.util.UUID
import be.uclouvain.organisation.platform.util.MissionParameters


/** 
 * @TODO : provide a description
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $Surveillance$
 * 
 */
behavior UserRole extends ElementRole {

	uses Behaviors, UserElementCapacity, InnerContextAccess, Lifecycle, Logging
	
	val entityList : HashMap<UUID, CharacterData> = new HashMap<UUID, CharacterData>
	val AVAILABLE_EXPERTS = 4; //
	val EXPERTISE_DEGREE = newArrayList(1, 2, 3, 0)

	var availablePlatforms = new LinkedList<String>
	
	var parentPrivateChanel : OpenEventSpace
	
	@SuppressWarnings("potential_field_synchronization_problem")
	on Initialize {
		
		
		availablePlatforms.addAll(occurrence.parameters.get(0) as LinkedList<String>)
		
		debug("initial platforms " + availablePlatforms)
		for (var i = 0; i < AVAILABLE_EXPERTS; i++) {
			val id = UUID.randomUUID
			entityList.put(id, new CharacterData(id.toString, EXPERTISE_DEGREE.get(i), 0, -1))
			spawnInContextWithID(Expert,id, innerContext) //@FIXME : the Expert is an Entity that must live in the TOLD Context
		}
			setupPhysicalDevice(getExpertTypeList)}
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on ElementInformation {
		
		val msg = occurrence.information; 
		if (msg instanceof UDP_Message_RequestSpawn) {
			
			val entityID = UUID.fromString(msg.actorUID)

			parentPrivateChanel.emit(this.ID,
				new NewMission(
					new MissionData(
						UUID.randomUUID, 
						entityID, 
						availablePlatforms.get(msg.sceneID),
							new MissionParameters(
								entityList.get(entityID).evolution, 
								true)
							)
						)
					)[it.UUID !== this.ID ]
			entityList.get(entityID).screenID = msg.sceneID
			updateBehavior(getExpertTypeList)
			}
			else if (msg instanceof UDP_Message_RequestWithdraw) {
			var MissionID = UUID.fromString(msg.actorUID)
			entityList.get(MissionID).screenID = -1
			wake(new StopMission(MissionID))[it.UUID==MissionID]
			updateBehavior(getExpertTypeList)
		}
	}
	
	on HolonicParentInfo {
		info("I met my parent")
		parentPrivateChanel = occurrence.spaceID
		parentPrivateChanel.register(asEventListener)
	}
	
	on AuthorizedMission {
		
		info("receives authorisation for mission")
		wake(
			new NewMission(occurrence.mission, occurrence.platformOpenChannel)) [
			it.UUID == occurrence.mission.expertID
		]
	}
	def getExpertTypeList {
		var characterList : CharacterData[] = newArrayOfSize(20)
		var i = 0;
		for (id : entityList.keySet) {
			var cD = entityList.get(id)
			characterList.set(i, cD)
			i++
		}
		return characterList
	}
	def getEntityList : HashMap<UUID, CharacterData> {
		return this.entityList
	}
} 