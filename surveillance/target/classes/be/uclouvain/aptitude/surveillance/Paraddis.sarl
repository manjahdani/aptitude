/** 
 * 
 */
package be.uclouvain.aptitude.surveillance


import io.sarl.core.Destroy
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.core.MemberJoined
import io.sarl.core.ParticipantJoined

/** 
 * The agent gives global trait to agents. 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.1$
 * @date $31/03/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */
 


agent Paraddis {
	uses Lifecycle, Logging, InnerContextAccess, Schedules

	protected var AgentType : String = 'Unknown'
	
//on Initialize {
	//	// Event trigger before the agent begin to live or to be used.
	//
	//				/* 
	//	 * The goal in the statements below is to help us setting the AgentType in 
	//	 * order to have an idea of which agents is producing which <<log
	//	 */
	//	val Classa = this.class.toString // to get the class of the agent
	//	 synchronized (AgentType)
	//	 switch (Classa) {
	//	 case "class be.uclouvain.launcher.bootAgent": {
	//	  AgentType = "Boot"}
	//	  case "class be.uclouvain.aptitudeAgents.PlatformAgent":{
	//	  	AgentType="Platform"
	//	  }
	//	  default:{
	//	  	AgentType ='AgentNotKnown' 
	//	  	info(Classa)
	//	  	}}
	//
	//	loggingName = AgentType + "-" + this.ID
	//	 synchronized (AgentType)
	//info(" agent was started.")
	//}
	on Destroy {
		// synchronized (AgentType)
			info("Stopped.")
	}

	on MemberJoined {
		debug(" noticed " + occurrence.agentType.replaceAll("be.uclouvain.aptitude.surveillance.", " - ") +
				" - &ID : " + occurrence.agentID.toString.substring(0, 5))
	}

	on ParticipantJoined {
		//@DEBUG
		//info("Participant  - " + occurrence.source.ID.toString.substring(0, 5) + " - Joined space -" +
			//occurrence.spaceID)
	}

	on CommitSuicide {
		
		//info("received commitSuicide : " + occurrence.fromMe + " : " + occurrence.source.ID) 
		terminateAgent
	}

	def terminateAgent {

		/* 
		 * Protocol 
		 * 1. Kill sub-holons 
		 * 2. Cancel tasks
		 * 3. terminate agent
		 */
		
		if (hasMemberAgent) {
			KillMembers
		} else if (!getActiveTasks.isEmpty) {

			CancelTasks
		} else {
			killMe
		}
	}

	
	def KillMembers {
		
		
		for (h : memberAgents) {
			innerContext.defaultSpace.emit(this.ID, new CommitSuicide)[it.ID == h]
		}
		val waitTask = task("wait-member-killed-task")
		waitTask.every(2000) [
			if (!hasMemberAgent) {
				CancelTasks
			}
		]
	}
	
	def CancelTasks{
		
		var tasksInProgress = getActiveTasks
		for (t : tasksInProgress) {
			task(t).cancel
			tasksInProgress.remove(t)
			// @DEBUG info("done cancelling : " + getActiveTasks)
	}
	
	val waitTask = task("final-task")
	waitTask.every(1000)[
		if(tasksInProgress.isEmpty){
			waitTask.cancel
			killMe	
		}
	]
}		
}