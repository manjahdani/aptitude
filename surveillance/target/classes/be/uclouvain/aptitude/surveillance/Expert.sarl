package be.uclouvain.aptitude.surveillance

import be.uclouvain.organisation.AuthorizationToJoinContext
import be.uclouvain.organisation.RequestToJoin
import be.uclouvain.organisation.platform.AnalystRole
import be.uclouvain.organisation.platform.NewMission
import be.uclouvain.organisation.platform.StopMission
import be.uclouvain.organisation.told.entity.EntityRole
import io.sarl.core.Behaviors
import io.sarl.core.ContextJoined
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import java.util.HashMap
import java.util.UUID

/** 
 * The expert receives the requirements of the client and translates them into a mission.
 * 
 * The goal of the expert is to draw conclusions such as statistics or occurrence of events. It will uses for that the help of algorithms and Sensors.
 * 
 * @FIXME : It is strange that the sensitivity is sent. Maybe its best that platform creates a space where they could discuss
 * @FIXME : Maybe expert or probably platform creates a space (a channel between them) for the discussion
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 */ 

agent Expert extends Paraddis {
	
	uses Logging, Behaviors, ExternalContextAccess, InnerContextAccess
	
	var missionList = new HashMap<UUID, String> // The different Mission its responsible the first entry is the mission list and the second the ContextID
	var encounteredPlatforms = new HashMap<String, OpenEventSpace>
	var publicChannel : OpenEventSpace
	
	@SuppressWarnings("potential_field_synchronization_problem")
	on Initialize {
		loggingName = this.ID + "-Expert"   
		registerBehavior(new EntityRole(this))
		publicChannel = innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID)
		publicChannel.register(asEventListener) 	// public channel
		
	}
	@SuppressWarnings("potential_field_synchronization_problem", "discouraged_occurrence_readonly_use")
	on NewMission {
		
		info("has a new mission " + occurrence.mission.location)

		registerBehavior(new AnalystRole(this),
			occurrence.mission.setPlatformID(occurrence.platformOpenChannel.spaceID.contextID)) // // @FIXME: Not natural (MEDIUM Priority) The contextID of the space is the one of the platform as the platform generated the space.
		
		 
		// Check whether the agent already lives in the context of the platform where it has to pursue the mission
		// We assume that the platformOpenChanel is created within the platform such that we could retrieve the contextID which is the platform ID.  
		if (!isInContext(occurrence.mission.platformID)) {
			//The agent is not in the context. The agent starts a task to join the context.
			occurrence.platformOpenChannel.emit(new RequestToJoin(publicChannel)) [
				it.UUID == occurrence.mission.platformID
			] 	
		}
		
		//val PlatformSpace = platformlistenersSpaceIDs.get(PlatformID)
		// MissionList.put(occurrence.missionData.entityID, PlatformSpace)
		missionList.put(occurrence.mission.missionID, occurrence.mission.location)
		encounteredPlatforms.put(occurrence.mission.location, occurrence.platformOpenChannel)
	}

	@SuppressWarnings("potential_field_synchronization_problem", "discouraged_occurrence_readonly_use")
	
	//@FIXME This should be in the role rather in the agent. 
	on StopMission {
		info("received Stop Mission")
		var platformLocation = missionList.get(occurrence.expertID) // @TODO : The experts may be on hold at this point
		info("received Stop mission at " + platformLocation)
		encounteredPlatforms.get(platformLocation).emit(new StopMission(occurrence.expertID))
	}
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on AuthorizationToJoinContext {
		info(
			"receives authorisation to join the context of - " + occurrence.source.UUID.toString.substring(0, 5) +
				" and space " + occurrence.defaultSpaceID)
		join(occurrence.contextID, occurrence.defaultSpaceID)
	}
	
	on ContextJoined {
		//info("all experts context -- " + allContexts)
		//info("defaultSpaceJoined -- " + occurrence.defaultSpaceID)
	}

	def isInContext(contextID : UUID) {

		for (ctxt : allContexts) {
			if (ctxt.ID == contextID) {
				return true
			}
		}
		return false
	}
}
