/** 
 * 
 */
package be.uclouvain.aptitude.surveillance.algorithm


import com.hazelcast.util.UuidUtil
import io.sarl.core.AgentTask
import io.sarl.core.Logging
import io.sarl.core.Schedules
import org.json.simple.JSONObject
import be.uclouvain.aptitude.surveillance.algorithm.messages.ActionMessage
import be.uclouvain.aptitude.surveillance.algorithm.messages.RequestMessage
import be.uclouvain.aptitude.surveillance.algorithm.messages.BaseMessage

/** 
 * 
 * 
 */
abstract skill PythonAccess implements PythonTwinObserverAccess {
	uses Logging, Schedules

	protected var topicRequestSub : String
	protected var topicSignalAcquisition : String

	protected var pendingRequestID : String
	protected var requestTask : AgentTask

	@SuppressWarnings("potential_field_synchronization_problem")
	def install {
		topicRequestSub = CommunicationManager.instance.subscribeTopic("request", this)
	}
	def prepareUninstallation {
		// Function invoked when the skill is preparing to be uninstalled from the owner, but before the owner is destroyed.
		// You should put all the resource release statements that should be executed before the owner is destroyed.
		info("Preparing the uninstallation of the skill")
	}
	@SuppressWarnings("potential_field_synchronization_problem")
	def uninstall {		
			if (topicRequestSub !== null) {
				CommunicationManager.instance.unsubscribeTopic(topicRequestSub)
				topicRequestSub = null
			}
			if (topicSignalAcquisition !== null) {
				CommunicationManager.instance.unsubscribeTopic(topicSignalAcquisition)
			topicSignalAcquisition = null
			}
	}
	@SuppressWarnings("potential_field_synchronization_problem")
	def ActivateAccess(jsonConfig : JSONObject) {
		this.pendingRequestID = UuidUtil.newSecureUuidString
		this.requestTask = every(1000) [
			info("Python partner not found, send discovery message")
			var requestMessage = new RequestMessage()
			requestMessage.requestID = this.pendingRequestID
			requestMessage.agentID = owner.ID.toString
			requestMessage.jsonConfig = jsonConfig.toString
			CommunicationManager.instance.publishMessage(topicRequestSub, requestMessage)
		]
	}

	@SuppressWarnings("potential_field_synchronization_problem")
	def UpdateStreamAccess(actionID : int) {
		info("Send action: " + actionID)
		var actionMessage = new ActionMessage()
		actionMessage.actionID = actionID
		CommunicationManager.instance.publishMessage(topicSignalAcquisition, actionMessage)
	}

	@SuppressWarnings("potential_field_synchronization_problem")
	def Signal2Perception(detectionMessage : Object) {
		CommunicationManager.instance.publishMessage(topicSignalAcquisition, detectionMessage as BaseMessage)
	}
}
