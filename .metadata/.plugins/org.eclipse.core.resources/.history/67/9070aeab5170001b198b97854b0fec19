/** 
 * 
 */
package be.uclouvain.aptitudeAgents

import io.sarl.core.Behaviors
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.lang.core.EventSpace
import java.util.TreeMap
import java.util.UUID

/** 
 * @author manjah
 * 
 */
agent PlatformAgent2 {

	uses Logging, Behaviors, InnerContextAccess, Lifecycle

	val subPlatformSpaceIDs = new TreeMap<UUID, EventSpace> // TreeMap of the sub-worlds composing the world. It is used to be able to communicate with other worlds

	on Initialize {
		val WorldConfig = occurrence.parameters.get(0) as PlatformConfig

		loggingName = "Platform-" + WorldConfig.getLevel() + "-" + this.ID

		/* 
		 * Setting Roles and associated capacities of "WorldRole & TimeManagerBehavior"
		 */
		 
		// setSkill(new DiscreteTimeFlow, TimeManager)
		// registerBehavior(new TimeManagerBehavior(this))

		/* 
		 * Spawn of sub-worlds 
		 */
		for (swc : PlatformConfig.PlatformConfig) {
			val randomID = UUID.randomUUID
			spawnInContextWithID(PlatformAgent2, randomID, innerContext, swc)
			subPlatformSpaceIDs.put(randomID, innerContext.getDefaultSpace)
		}
		if (WorldConfig.getLevel > 0) {
			setSkill(new CyberWorld3DSkill(WorldConfig), CyberWorld3DCapacity)
			registerBehavior(new CyberWorld3DRole(this))
			spawnInContext(GameEngine, innerContext, WorldConfig.getServer, WorldConfig.getPCaddrss) 	// Only first layer wouldn't have a unity server, as it doesn't need to have physical representation
		} else {
			setSkill(new WorldSkill(WorldConfig), WorldCapacity)
			registerBehavior(new WorldRole(this))
			spawn(UserInterface, "NetworkDeviceManager", subWorldSpaceIDs)
		}
	}

}
