
package be.uclouvain.aptitude.surveillance.algorithm

import be.uclouvain.organisation.platform.LeavePlatform
import be.uclouvain.organisation.platform.MissionSensitivity
import be.uclouvain.organisation.platform.ObserverRole
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import java.io.FileReader
import java.util.TreeMap
import org.json.simple.JSONObject
import org.json.simple.parser.JSONParser
import be.uclouvain.organisation.platform.AddAlgorithm
import be.uclouvain.organisation.told.util.AlgorithmInfo

/** 
 * @FIXME : IMPROVEMENT : the Hazelcast only need to send the frame number and the ids.  Will it make sens ? 
 * @TODO : Any Observer would transmit the read-only pointer to the memory space
 * that contains the information requested upon approved request from another. 
 * 
 * It does make sens to have a certain window of information in memory and the 
 * other one stored in a database. Therefore, 
 *  the database with a certain window 
 * in situ and otherwise stored in TOLD
 * We need to find a way such that the information is synchronized before potential fusion 
 *
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.1$
 * @date $31/03/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $organisation$
 * 
 */
behavior TrackerRole extends ObserverRole {
	uses Logging, PythonTwinObserverAccess, DefaultContextInteractions

	var partnerTrackingName : String


	val intensityMap = new TreeMap<Integer, Integer> 
	
	val availableObservers = newArrayList("TinyYOLO", "YOLO") //@FIXME should be given by the Analyst which makes it configurable ? 
	on Initialize {
		intensityMap.put(0, 1)
		intensityMap.put(1, 0)
		intensityMap.put(2, 0)
		intensityMap.put(3, 1)
		setSkill(new TrackerPythonTwin)
		var parser = new JSONParser(); 
		var configPathTracker = occurrence.parameters.get(0).toString
		var jsonTracker = parser.parse(new FileReader(configPathTracker)) as JSONObject;
		ActivateAccess(jsonTracker)
	}

	on Destroy {
		info("The behavior was stopped.")
	}

	@SuppressWarnings("potential_field_synchronization_problem")
	on PartnerTrackingFound {
		this.partnerTrackingName = occurrence.partnerName
		info("Tracking Partner found: " + this.partnerTrackingName)
	}
	on LeavePlatform {
		// join(BaseContext.ID, BaseSpace.spaceID.ID)
		info("ObserverTrackerLeaving")
		UpdateStreamAccess(4)
			// leave(PlatformID)
	}

	on MissionSensitivity {
		sensitivity.set(occurrence.s)
		val ObserverName = availableObservers.get(intensityMap.get(sensitivity.get))
		info("Come here : " + ObserverName)

		PlatformSpace.emit(this.ID,new AddAlgorithm(MissionSpace, new AlgorithmInfo(ObserverName, "DETECTOR")))[it.UUID == PlatformContext.ID]
	}

	on BBoxes2DTrackResult {
		emit(new BBoxes2DTrackResult(occurrence.bboxes2DTrack))[it.UUID == observerID]
		 //println("***********************")
		 //println("* Tracking " + occurrence.bboxes2DTrack.frameNumber)
		// println("*  " + occurrence.bboxes2DTrack.trackingTime)
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.globalIDs))
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.bboxes))
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.classIDs))
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.detConfs))
		// println("*  " + occurrence.bboxes2DTrack.lastFrame)
		// println("***********************")
	}
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on BBoxes2DResult {
		
		Signal2Perception(occurrence.bboxes2D)
		//getPerception(occurrence.bboxes2D)
	}
}
