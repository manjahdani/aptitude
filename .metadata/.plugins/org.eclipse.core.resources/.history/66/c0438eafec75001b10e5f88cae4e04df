/** 
 * 
 */
package be.uclouvain.agents.util

import java.util.concurrent.atomic.AtomicInteger
import org.arakhne.afc.math.geometry.d2.d.Point2d
import java.util.ArrayList
import org.arakhne.afc.math.geometry.d2.d.Vector2d

/** 
 * @author manjah
 * 
 */
class countingLine {
	
	
	
	public var direction : int;
	public var lowerX : double
	public var upperX : double
	public var lowerY : double
	public var upperY : double
	public val counts = new AtomicInteger(0)
  	public val ObjEncountered = new ArrayList<Integer>
  	val normale : Vector2d;
	
	val ANGLE_ALONGSIDE = Math.PI*80/180; 
	val ANGLE_OPPOSITE = Math.PI*120/180;
	
	new (lX : double, lY : double, uX : double, uY : double, d : int) {
		this.lowerX = lX
		this.upperX = uX
		this.lowerY = lY
		this.upperY = uY
		this.direction = d
		this.normale = get_normale(new Point2d(lX,lY), new Point2d(uX,uY), direction)
	}

	def isInWorldLimit(x : double, y : double, z : double) : boolean {
		if (x > lowerX && x < upperX) {
			return false
		}
		if (y > lowerY && y < upperY) {
			return false
		}
		
		return true
	}

	def CopyWorld(w : countingLine) {
		this.lowerX = w.lowerX
		this.upperX = w.upperX
		this.lowerY = w.lowerY
		this.upperY = w.upperY
		this.direction = w.direction
	}
	
	def getCounts
	{
		return this.counts
	}
	
	def IncrementCounts{
		
		this.counts.andIncrement
	}
	def getLine {
		return newArrayList(new Point2d(lowerX,lowerY),new Point2d(upperX,upperY))
	}
	
	def ObjectEncountered(ID : int) {
		
		if(ObjEncountered.contains(ID)){
			return true
		}
		else{
			ObjEncountered.add(ID)
			return false
		}
	}
	def getNormale{
		return this.normale
	}

	def get_normale(P1 : Point2d, P2:Point2d, flag : int) {
	//
		//    """
    //# Flag :  1  gives the normale towards South or West
    //# Flag : -1  gives the normale towards North or East
    //"""
    var A:Point2d = P1
    var B:Point2d = P2
    
    if (P1.x > P2.x) { // Make sure that A is with the point with inferior X
        A = P2
        B  = P1}
        
    var m = (B.y-A.y)/(B.x-A.x) //#slope
    var norm_n = Math.sqrt(m*m + 1)*flag
    return (new Vector2d(-m/norm_n, 1/norm_n))
	}
	
	def Orientation(v : Vector2d){
		
		var angle=this.normale.angle(v)
		
		if (angle < ANGLE_ALONGSIDE) {
			return 1
		}
		if (angle > ANGLE_OPPOSITE) {
			return -1
		}		
		return 0
		
	}
	
}


	

