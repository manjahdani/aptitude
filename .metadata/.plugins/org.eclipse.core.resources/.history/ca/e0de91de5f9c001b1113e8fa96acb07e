/** 
 * 
 */
package be.uclouvain.aptitude.surveillance

import be.uclouvain.aptitude.surveillance.algorithm.Algorithm
import be.uclouvain.organisation.told.TOLDRole
import io.sarl.core.Behaviors
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.lang.core.AgentContext
import java.util.ArrayList
import java.util.UUID
import be.uclouvain.organisation.told.AccessDatabaseCapacity
import be.uclouvain.organisation.told.VirtualDatabaseSkill
import be.uclouvain.organisation.told.util.AlgorithmInfo
import java.util.HashMap
import java.util.stream.Collectors
import java.util.Map;
import java.util.Map.Entry

/** 
 * 
 * The agent TOLD keeps record of current and past knowledge. 
 * The size of the database is a parameter and therefore we could have local TOLD 
 * that communicates to a higher TOLD itself communicating to a bigger database. 
 * The TOLD agent creates within its context spaces, as many agents as there are different tasks. 
 * Therefore a space for Detectors, Trackers, Vehicle Counter and broadly speaking each class of algorithms.    
 * 
 * @author $Author: manjahdani$
 * @version $0.1$
 * @date $31/03/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 */ 
agent TOLDAgent extends Paraddis {
	uses Logging, Lifecycle, InnerContextAccess, Behaviors

 	val INIT_TASKS : ArrayList<String> = newArrayList("DETECTOR","TRACKER","COUNTER") // @parameters

	on Initialize {
		
		loggingName = "TOLD-" + this.ID
		info("Ready to share my stored Knowledge.")
		val S = setSkill(new VirtualDatabaseSkill, AccessDatabaseCapacity)
		registerBehavior(new TOLDRole(this))
		
	
		
		val onlyAlgorithms : HashMap<UUID,AlgorithmInfo> = new HashMap(S.database.filter[p1, p2|p2 instanceof AlgorithmInfo]) // Make sure that we only consider the algorithmsINFO
		
	
		
		for (t : INIT_TASKS){
				spawnInContext(Algorithm,innerContext, 0, t)
			}
		
	}	
//	@SuppressWarnings("discouraged_occurrence_readonly_use")
//	on AlgorithmJoinPlatform {
//		info("I received Algorithm Join Platform" + AlgorithmDatabase.get(occurrence.name))
//		wake(new AlgorithmNeeded(occurrence.contextID,occurrence.defaultSpaceID, occurrence.name, occurrence.task, AlgorithmDatabase.get(occurrence.name), occurrence.source.UUID))
//	}
//}
	//emit(new StoredAlgorithms(INIT_TASKS))
}


event AlgorithmNeeded {
	val contextID : AgentContext
	val DefaultSpaceID : OpenEventSpace
	val name : String
	val task : String
	val belief : String
	val dest : UUID

	new (context : AgentContext, Space : OpenEventSpace, n:  String,t : String, bel : String, d:UUID) {
		this.contextID = context
		this.DefaultSpaceID = Space
		this.task = t; 
		this.belief = bel;
		this.name=n
		this.dest=d
	}
}
