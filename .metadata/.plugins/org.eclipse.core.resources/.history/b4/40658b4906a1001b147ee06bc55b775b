/** 
 * 
 */
package be.uclouvain.aptitude.surveillance.algorithm

import be.uclouvain.aptitude.surveillance.algorithm.messages.BaseMessage
import be.uclouvain.aptitude.surveillance.algorithm.messages.EvaluationMessage
import be.uclouvain.aptitude.surveillance.algorithm.messages.RequestMessage
import be.uclouvain.organisation.platform.ObserverCapacity
import com.hazelcast.util.UuidUtil
import io.sarl.core.AgentTask
import io.sarl.core.Behaviors
import io.sarl.core.Logging
import io.sarl.core.Schedules
import org.json.simple.JSONObject

/** 
 * @TODO: write a description
 * 
 * @author $Author: manjahdani$
 * @version $0.0.1$
 * @date $31/03/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */
capacity PythonTwinObserverAccess extends ObserverCapacity{

	def ActivateAccess(j : JSONObject)
	
	def UpdateStreamAccess(a : int)

	def update(m : BaseMessage)
	
}

capacity Detection extends PythonTwinObserverAccess{
	
	def sendDetectorAction(actionID : int, newFrameNumber : int)
}

/** 
 * @author samelson
 * 
 * @TODO : Check 
 */
capacity Evaluation extends PythonTwinObserverAccess {

	def requestEvaluator(jsonConfig : JSONObject)

	def sendEvaluationRequest(requestID : String, predictions : String, gts : String)
}




//@FIXME Methods are not fully the same. 
skill EvaluationImpl implements Evaluation {
	uses Logging, Behaviors, Schedules
	
	var topicRequestSub : String
	var topicEvalSub : String

	var pendingRequestID : String
	var requestTask : AgentTask

	def install {
		topicRequestSub = CommunicationManager.instance.subscribeTopic("request", this)
	}

	def uninstall {
		if (topicRequestSub !== null) {
			CommunicationManager.instance.unsubscribeTopic(topicRequestSub)
			topicRequestSub = null
		}
		if (topicEvalSub !== null) {
			CommunicationManager.instance.unsubscribeTopic(topicEvalSub)
			topicEvalSub = null
		}
	}

	def requestEvaluator(jsonConfig : JSONObject) {
		this.pendingRequestID = UuidUtil.newSecureUuidString
		this.requestTask = every(1000) [
			info("Evaluator partner not found, send discovery message")
			var requestMessage = new RequestMessage()
			requestMessage.requestID = this.pendingRequestID
			requestMessage.agentID = owner.ID.toString
			requestMessage.jsonConfig = jsonConfig.toString
			CommunicationManager.instance.publishMessage(topicRequestSub, requestMessage)
		]
	}

	def update(m : BaseMessage) {
		if (m instanceof EvaluationMessage) {
			if (m.ack) {
				wake(new EvaluationResult(m))
			}
		} else if (m instanceof RequestMessage) {
			onRequestMessage(m)
		}
	}

	private def onRequestMessage(message : RequestMessage) {
		if (message.ack && message.requestID == this.pendingRequestID) {
			requestTask.cancel
			CommunicationManager.instance.unsubscribeTopic(topicRequestSub)
			topicRequestSub = null
			val topicName = "evaluation_" + owner.ID.toString + "_" + message.clientName
			topicEvalSub = CommunicationManager.instance.subscribeTopic(topicName, this)
			wake(new PartnerEvaluationFound(message.clientName))
		}
	}
	
	def sendEvaluationRequest(requestID: String, predictions : String, gts : String) {
		var evalMessage = new EvaluationMessage()
		evalMessage.requestID = requestID
		evalMessage.predictions = predictions
		evalMessage.gts = gts
		CommunicationManager.instance.publishMessage(topicEvalSub, evalMessage)
	}
	
	def ActivateAccess(j : JSONObject) {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
	def UpdateStreamAccess(a : int) {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
	def Signal2Perception(signal : Object) {
		throw new UnsupportedOperationException("TODO: auto-generated method stub")
	}
	
}
