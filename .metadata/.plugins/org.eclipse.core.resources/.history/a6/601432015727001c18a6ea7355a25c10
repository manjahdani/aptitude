package be.uclouvain.aptitude.surveillance

import be.uclouvain.organisation.platform.AddMission
import be.uclouvain.organisation.platform.AnalystRole
import be.uclouvain.organisation.platform.NewMission
import be.uclouvain.organisation.platform.StopMission
import be.uclouvain.organisation.told.entity.EntityRole
import io.sarl.core.Behaviors
import io.sarl.core.ContextJoined
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import java.util.HashMap
import java.util.UUID
import io.sarl.lang.core.AgentContext
import java.util.LinkedList
import io.sarl.core.InnerContextAccess
import io.sarl.core.OpenEventSpaceSpecification

/** 
 * The expert receives the requirements of the client and translates them into a mission.
 * 
 * The goal of the expert is to draw conclusions such as statistics or occurrence of events. It will uses for that the help of algorithms and Sensors.
 * 
 * @FIXME : It is strange that the sensitivity is sent. Maybe its best that platform creates a space where they could discuss
 * @FIXME : Maybe expert or probably platform creates a space (a channel between them) for the discussion
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 */ 

agent Expert extends Paraddis {
	
	uses Logging, Behaviors, ExternalContextAccess, DefaultContextInteractions, InnerContextAccess
	
	var missionList = new HashMap<UUID, String> // The different Mission its responsible the first entry is the mission list and the second the ContextID
	var encounteredPlatforms = new HashMap<String, OpenEventSpace>
	
	var activeContexts = new LinkedList // List of the platforms that expert is within their context
	
	var openSpace = innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID)
	@SuppressWarnings("potential_field_synchronization_problem")
	on Initialize {
		loggingName = this.ID + "-Expert"   
		registerBehavior(new EntityRole(this))
		openSpace.register(asEventListener)// public channel 
		
	}
	@SuppressWarnings("potential_field_synchronization_problem", "discouraged_occurrence_readonly_use")
	on NewMission {
		
		info("has a new mission " + occurrence.mission.location)
		

		registerBehavior(new AnalystRole(this), occurrence.mission)
		
		// @FIXME: Not natural (MEDIUM Priority) 
		// Check whether the agent already lives in the context of the platform where it has to pursue the mission
		// We assume that the platformOpenChanel is created within the platform such that we could retrieve the contextID which is the platform ID.  
		if (!isInContext(occurrence.platformChanel.spaceID.contextID)) {
			//The agent is not in the context. The agent starts a task to join the context.
		 	occurrence.platformChanel.emit(new RequestToJoin())
		}
		
		//val PlatformSpace = platformlistenersSpaceIDs.get(PlatformID)
		// MissionList.put(occurrence.missionData.entityID, PlatformSpace)
		missionList.put(occurrence.mission.getMissionID, occurrence.mission.location)
		
		encounteredPlatforms.put(occurrence.mission.location, occurrence.platformChanel)
		info("starts mission with spaceID - " + occurrence.platformChanel.spaceID.ID)
		occurrence.platformChanel.emit(
			new AddMission(getDefaultSpace(), occurrence.mission))[it.UUID==occurrence.platformChanel.spaceID.contextID] //The contextID of the space is the one of the platform as the platform generated the space.  
			 //@FIXME A lot receives the message. 
	}

	@SuppressWarnings("potential_field_synchronization_problem", "discouraged_occurrence_readonly_use")
	
	//@FIXME This should be in the role rather in the agent. 
	on StopMission {
		info("received Stop Mission")
		var platformLocation = missionList.get(occurrence.expertID) // @TODO : The experts may be on hold at this point
		info("received Stop mission at " + platformLocation)
		encounteredPlatforms.get(platformLocation).emit(new StopMission(occurrence.expertID))
	}
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on AuthorizationToJoinContext {
		info("receives authorisation to join the context of - " + occurrence.source.UUID.toString.substring(0, 5) + " and space " +
			occurrence.contextID.defaultSpace)
		join(occurrence.contextID.getID, occurrence.contextID.defaultSpace.getSpaceID.getID)
		
	}
	
	def isInContext(contextID : UUID) {

		for (ctxt : allContexts) {
			if (ctxt.ID == contextID){
				return true
			}
		}
		return false
	}
	on ContextJoined {
		info("All expert Context" + allContexts)
		info("DefaultSpaceJoined" + occurrence.defaultSpaceID)
	}
}
