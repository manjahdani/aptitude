/** 
 */
package be.uclouvain.organisation.platform

import be.uclouvain.organisation.AddMember
import be.uclouvain.organisation.AuthorizationToJoin
import be.uclouvain.organisation.LocalDatabaseRequest
import be.uclouvain.organisation.PlatformOrganisationInfo
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import java.util.TreeMap
import java.util.UUID

/** 
 * Ensures the management of the associated resources (computational and sensors) of a Location 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.1$
 * @date $31/03/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $organisation$
 *   
 */
behavior PlatformRole {
	uses Behaviors, InnerContextAccess, ExternalContextAccess, DefaultContextInteractions, Logging

	protected var PlatformTOLDSpace : OpenEventSpace
	val Listeners : TreeMap<UUID, OpenEventSpace> = new TreeMap<UUID, OpenEventSpace>
	
	
	@SuppressWarnings("potential_field_synchronization_problem")
	on Initialize {
		this.PlatformTOLDSpace = innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID) // Space for the communication between Unity and the World
		PlatformTOLDSpace.register(asEventListener)
	}

	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on AddMission {
		// RuleManagement(new MembershipInfoRule(occurrence.source, occurrence.SourceEventSpace, occurrence.entityData))
		//if (true) {
			emit(occurrence.SourceEventSpace,
				new AuthorizationToJoin(innerContext, innerContext.getDefaultSpace as OpenEventSpace, occurrence.source.getUUID, occurrence.MissionData))[it.UUID == occurrence.source.getUUID]
		//}
	}

	@SuppressWarnings("discouraged_occurrence_readonly_use", "potential_field_synchronization_problem")
	
	//@FIXME is it possible to generalize that ? 
	on MemberJoined {

		val MemberID = occurrence.agentID;
		Listeners.put(MemberID, innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID))
		
		Listeners.get(MemberID).register(asEventListener)
		
		if (occurrence.inDefaultSpace) {
			emit(new PlatformOrganisationInfo(innerContext, Listeners.get(MemberID)))[it.UUID == MemberID]
			if(occurrence.agentType.contains("TOLD"))
			{
				info("I met TOLD")
				PlatformTOLDSpace=Listeners.get(MemberID)
			}
		}
		else {
			wake(new PlatformOrganisationInfo(innerContext, Listeners.get(MemberID)))[it.UUID == MemberID]
		}
	}
	@SuppressWarnings("potential_field_synchronization_problem")
	on LocalDatabaseRequest{
		PlatformTOLDSpace.emit(new AddMember(Listeners.get(occurrence.source.UUID)))
	}
	@SuppressWarnings("potential_field_synchronization_problem")
	on AddAlgorithm {
		//if(RuleManagement)
		PlatformTOLDSpace.emit(new AlgorithmJoinPlatform(innerContext, PlatformTOLDSpace, occurrence.info.name,
				occurrence.info.task))
	}
	

	on StopMission {

		//if(RuleManagement())
		info(" I received a Stop Misson" + occurrence.expertID)
		
		wake(new LeavePlatform)
	}

}
