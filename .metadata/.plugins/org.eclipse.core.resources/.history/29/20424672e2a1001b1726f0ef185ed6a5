
package be.uclouvain.aptitude.surveillance.algorithm

import be.uclouvain.organisation.platform.LeavePlatform
import be.uclouvain.organisation.platform.MissionSensitivity
import be.uclouvain.organisation.platform.ObserverRole
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import java.io.FileReader
import java.util.TreeMap
import org.json.simple.JSONObject
import org.json.simple.parser.JSONParser
import be.uclouvain.organisation.platform.AddAlgorithm
import be.uclouvain.organisation.told.util.AlgorithmInfo
import java.io.FileWriter
import java.util.LinkedList
import java.util.Collections
import be.uclouvain.aptitude.surveillance.algorithm.util.BBoxes2D
import be.uclouvain.aptitude.surveillance.algorithm.util.BBOX
import java.util.ArrayList

/** 
 * @FIXME : IMPROVEMENT : the Hazelcast only need to send the frame number and the ids.  Will it make sens ? 
 * @TODO : Any Observer would transmit the read-only pointer to the memory space
 * that contains the information requested upon approved request from another. 
 * 
 * It does make sens to have a certain window of information in memory and the 
 * other one stored in a database. Therefore, 
 *  the database with a certain window 
 * in situ and otherwise stored in TOLD
 * We need to find a way such that the information is synchronized before potential fusion 
 *
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */
behavior TrackerRole extends ObserverRole {
	
	uses Logging, PythonTwinObserverAccess, DefaultContextInteractions

	var partnerTrackingName : String


	val intensityMap = new TreeMap<Integer, Integer>

	var gt :FileWriter
	val availableObservers = newArrayList("TinyYOLO", "YOLO") //@FIXME should be given by the Analyst which makes it configurable ? 
	
	var totalTrackerTime : long = 0
	val dynamicTrackingMemory = Collections.synchronizedList(new LinkedList<ArrayList<BBoxes2D>>)

	
	on Initialize {
		intensityMap.put(0, 1)
		intensityMap.put(1, 0)
		intensityMap.put(2, 0)
		intensityMap.put(3, 1)
		setSkill(new TrackerPythonTwin)
		var parser = new JSONParser(); 
		var configPathTracker = occurrence.parameters.get(0).toString
		var jsonTracker = parser.parse(new FileReader(configPathTracker)) as JSONObject;
		ActivateAccess(jsonTracker)
		
	}

	on Destroy {
		info("The behavior was stopped.")
	}

	@SuppressWarnings("potential_field_synchronization_problem")
	on PartnerTrackingFound {
		this.partnerTrackingName = occurrence.partnerName
		info("Tracking Partner found: " + this.partnerTrackingName)
	}
	on LeavePlatform {
		// join(BaseContext.ID, BaseSpace.spaceID.ID)
		info("ObserverTrackerLeaving")
		UpdateStreamAccess(4)
			// leave(PlatformID)
	}

	on MissionSensitivity {
		sensitivity.set(occurrence.s)
		val ObserverName = availableObservers.get(intensityMap.get(sensitivity.get))
		info("Come here : " + ObserverName)

		PlatformSpace.emit(this.ID,new AddAlgorithm(MissionSpace, new AlgorithmInfo(ObserverName, "DETECTOR")))[it.UUID == PlatformContext.ID]
	}

	on BBoxes2DTrackResult {
		//emit(new BBoxes2DTrackResult(occurrence.bboxes2DTrack))[it.UUID == observerID]
		
		var ratio_width = 1920.0 / occurrence.bboxes2DTrack.dimWidth
		var ratio_height = 1080.0 / occurrence.bboxes2DTrack.dimHeight
		var frameNumber = occurrence.bboxes2DTrack.frameNumber
		
		var tmp = newArrayList
		
		for (var i = 0; i < occurrence.bboxes2DTrack.numberObjects; i++) {
			var X = occurrence.bboxes2DTrack.bboxes.get(4 * i) * ratio_width
			var Y = occurrence.bboxes2DTrack.bboxes.get(4 * i + 1) * ratio_height
			var W = occurrence.bboxes2DTrack.bboxes.get(4 * i + 2) * ratio_width
			var H = occurrence.bboxes2DTrack.bboxes.get(4 * i + 3) * ratio_height
			var classID = occurrence.bboxes2DTrack.classIDs.get(i)
			var globalID = occurrence.bboxes2DTrack.globalIDs.get(i)
			var conf = occurrence.bboxes2DTrack.detConfs.get(i)
			
			gt.write(
				(frameNumber + 1).toString + "," + globalID.toString + "," + X.intValue.toString + "," + 
				 Y.intValue.toString + "," + 
				 W.intValue.toString + "," +
				 H.intValue.toString + "," + 
				 "-1" +
				  "," + "-1" + "," + "-1" + "," + "-1" + "\n"
			)

			tmp.add(new BBoxes2D(new BBOX(X, Y, W, H), conf, globalID, classID, frameNumber))

			if (ObjectPresentInframe.containsKey(globalID)) {
				ObjectPresentInframe.get(globalID).update(X, Y, W, H, classID, frameNumber, conf)
			} else {
				ObjectPresentInframe.put(globalID,
					)
			}
			
			
			dynamicTrackingMemory.add(
			ObjectToBeAnalyzed.add(ObjectPresentInframe.get(globalID))
		}
		 //println("***********************")
		 //println("* Tracking " + occurrence.bboxes2DTrack.frameNumber)
		// println("*  " + occurrence.bboxes2DTrack.trackingTime)
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.globalIDs))
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.bboxes))
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.classIDs))
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.detConfs))
		// println("*  " + occurrence.bboxes2DTrack.lastFrame)
		// println("***********************")
	}
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on BBoxes2DResult {
		
		Signal2Perception(occurrence.bboxes2D)
		//getPerception(occurrence.bboxes2D)
	}
}
