
package be.uclouvain.aptitude.surveillance.algorithm.tracker

import be.uclouvain.aptitude.surveillance.algorithm.BBoxes2DResult
import be.uclouvain.aptitude.surveillance.algorithm.BBoxes2DTrackResult
import be.uclouvain.aptitude.surveillance.algorithm.LastFrame
import be.uclouvain.aptitude.surveillance.algorithm.PythonObserverRole
import be.uclouvain.aptitude.surveillance.algorithm.PythonTwinObserverAccessCapacity
import be.uclouvain.aptitude.surveillance.algorithm.RestartDetector
import be.uclouvain.aptitude.surveillance.algorithm.TrackingPerception
import be.uclouvain.aptitude.surveillance.algorithm.TrackingRequest
import be.uclouvain.aptitude.surveillance.algorithm.util.BBOX
import be.uclouvain.aptitude.surveillance.algorithm.util.BBoxe2D
import be.uclouvain.organisation.SignalID
import be.uclouvain.organisation.platform.AddAlgorithm
import be.uclouvain.organisation.platform.AddMission
import be.uclouvain.organisation.platform.AddObserver
import be.uclouvain.organisation.platform.LeavePlatform
import be.uclouvain.organisation.platform.MissionSensitivity
import be.uclouvain.organisation.told.util.AlgorithmInfo
import be.uclouvain.python_access.messages.BBoxes2DTrackMessage
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.util.LinkedList
import java.util.ArrayList

/** 
 * @FIXME : IMPROVEMENT : the Hazelcast only need to send the frame number and the ids.  Will it make sens ? 
 * @TODO : Any Observer would transmit the read-only pointer to the memory space
 * that contains the information requested upon approved request from another. 
 * 
 * It does make sens to have a certain window of information in memory and the 
 * other one stored in a database. Therefore, 
 *  the database with a certain window 
 * in situ and otherwise stored in TOLD
 * We need to find a way such that the information is synchronized before potential fusion 
 *
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $surveillance$
 * 
 */
behavior TrackerRole extends PythonObserverRole {
	
	uses Logging, PythonTwinObserverAccessCapacity, DefaultContextInteractions,Lifecycle, Schedules
	
	
	val availableObservers = newArrayList("TinyYOLO", "YOLO") //@FIXME should be given by the Analyst which makes it configurable ? 
	var totalTrackerTime : double = 0
	var totalDetectorTime: double = 0
	
	//val dynamicTrackingMemory = Collections.synchronizedList(new LinkedList<ArrayList<BBoxes2D>>)
	var championName = "None"
	var championSensitivity = 5
	var LastFrame : int = 10000
	val FRAME_WIDTH = 1920.0 // @FIXME hardcoded value
	var FRAME_HEIGHT = 1080.0 // @FIXME hardcoded value
	
	@SuppressWarnings("potential_field_synchronization_problem")

	on LeavePlatform {
		// join(BaseContext.ID, BaseSpace.spaceID.ID)
		info("ObserverTrackerLeaving")
		UpdateStreamAccess(4)
		// leave(PlatformID)
	}
	
	on LastFrame {
		info("Receveived last frame " + listeners)
		
		for (l : listeners){
				missionSpaceList.get(l).emit(this.ID,
					new LastFrame(occurrence.frameNumber, ("F:\\Database\\".concat(this.ID.toString) + ".txt"), totalDetectorTime,
					totalTrackerTime)) [
					it.UUID == l
				]
	}}
	
	on TrackingRequest{
		// info("ReactivatingAccess")
		setSkill(new TrackerPythonTwin)
		ActivateAccess(jsonConfig)
		if (occurrence.bel.contains("Tiny")) {
			info("My Champion is SORT and TinyYOLO")
			championSensitivity = 1
			championName = "tinyYOLO" //@FIXME Its a hack
			emit(new RestartDetector("TinyYOLO"))
		}
		else{
			info("My Champion is SORT and YOLO")
			championSensitivity = 0
			championName = "YOLO" 
			emit(new RestartDetector("YOLO"))
		}
	}
	
	@SuppressWarnings("potential_field_synchronization_problem")
	
	

	on MissionSensitivity {
		
		//@FIXME We could totally generalize that. 
		sensitivity= new LinkedList(occurrence.s)
		if(sensitivity.size==1)
		{
			info("Hi")
			LastFrame = 50
			task("waitforConfig").every(500) [
				if (jsonConfig !== null) {
					setSkill(new TrackerPythonTwin)
					ActivateAccess(jsonConfig)
					task("waitforConfig").cancel
				}
			]
			// val ObserverName = availableObservers.get(intensityMap.get(sensitivity.get))
			val DetectorName = availableObservers.get(sensitivity.get(0))
			//info("Come here : " + DetectorName)	
			platformSpace.emit(this.ID,
				new AddObserver(missionSpaceList.values.get(0), new AlgorithmInfo(DetectorName, "DETECTOR"),
				new AlgorithmInfo(observerADN.name, "TRACKER")))[it.UUID == platformContext.ID] 	// @FIXME : Be very careful as I am taking the first Space
		}
		else {
			for(s : sensitivity)
			{
				info("Come here : " + observerADN.name)
				platformSpace.emit(this.ID,
					new AddAlgorithm(missionSpaceList.values.get(0),
					new AlgorithmInfo(observerADN.name, observerADN.task))) [
					it.UUID == platformContext.ID
				] 	// @FIXME : Be very careful as I am taking the first Space !!!! DANGER
			}
		}
	}
	on SignalID{
		platformContext.defaultSpace.emit(this.ID, new AddMission(missionSpaceList.values.get(0), null)) [
			it.UUID == occurrence.name
		]
	}

	on BBoxes2DTrackResult{
		
		totalDetectorTime += occurrence.bboxes2DTrack.detectionTime
		totalTrackerTime += occurrence.bboxes2DTrack.trackingTime 
		
		var ratio_width = FRAME_WIDTH / occurrence.bboxes2DTrack.dimWidth 
		var ratio_height = FRAME_HEIGHT / occurrence.bboxes2DTrack.dimHeight 
		
		var frameNumber = occurrence.bboxes2DTrack.frameNumber
		
		
		var tmp : ArrayList<BBoxe2D> = newArrayList 
		
		for (var i = 0; i < occurrence.bboxes2DTrack.numberObjects; i++) {
			var X = occurrence.bboxes2DTrack.bboxes.get(4 * i) * ratio_width
			var Y = occurrence.bboxes2DTrack.bboxes.get(4 * i + 1) * ratio_height
			var W = occurrence.bboxes2DTrack.bboxes.get(4 * i + 2) * ratio_width
			var H = occurrence.bboxes2DTrack.bboxes.get(4 * i + 3) * ratio_height
			var classID = occurrence.bboxes2DTrack.classIDs.get(i)
			var globalID = occurrence.bboxes2DTrack.globalIDs.get(i)
			var conf = occurrence.bboxes2DTrack.detConfs.get(i)
			tmp.add(new BBoxe2D(new BBOX(X, Y, W, H), conf, globalID, classID, frameNumber))
			}
			
			//dynamicTrackingMemory.add(frameNumber,tmp)
			
			for (l : listeners){
				info("MissionSpaceList" + missionSpaceList.isEmpty + "l " + l + "tmp is Null :" + tmp.isNullOrEmpty)
				info("missonSpaceList"+ missionSpaceList.get(l))
				info("missionSpaceList" + missionSpaceList)
				info("listeners" + listeners)
				missionSpaceList.get(l).emit(this.ID, new TrackingPerception(tmp))[it.UUID == l]
				}
			
			if (occurrence.bboxes2DTrack.lastFrame || frameNumber > LastFrame) {
				
				emit(new LastFrame(frameNumber))[it==me]
				for(p : providers){
				emit(new LeavePlatform)[it.UUID==p]}
				killMe
			}
			// println("***********************")
			 // println("* Tracking " + occurrence.bboxes2DTrack.frameNumber)
			 // println("*  " + occurrence.bboxes2DTrack.trackingTime)
			 // println("*  " + Arrays.toString(occurrence.bboxes2DTrack.globalIDs))
			 // println("*  " + Arrays.toString(occurrence.bboxes2DTrack.bboxes))
			 // println("*  " + Arrays.toString(occurrence.bboxes2DTrack.classIDs))
			 // println("*  " + Arrays.toString(occurrence.bboxes2DTrack.detConfs))
			 // println("*  " + occurrence.bboxes2DTrack.lastFrame)
			 // println("***********************")
	}
	@SuppressWarnings("discouraged_occurrence_readonly_use")


	on BBoxes2DResult {
		if(!providers.contains(occurrence.source.UUID)){
			providers.add(occurrence.source.UUID)
		}// @FIXME It is not necessary
		Signal2Perception(occurrence.bboxes2D)
	}
}

event BBoxes2DTrackResultToCounter extends BBoxes2DTrackResult{ //@FIXME : Nonsens
	
	var ObserverName : String
	var Sensitivity : int
	
	new (t : BBoxes2DTrackMessage, o : String, s: int){
		super(t)
		this.ObserverName = o
		this.Sensitivity=s
	}
	
}


/*
 * synchronized (this)
 * try {
 * gt.write(
 * (frameNumber + 1).toString + "," + globalID.toString + "," + X.intValue.toString + "," +
 * Y.intValue.toString + "," + W.intValue.toString + "," +
 * H.intValue.toString + "," + 
 * "-1" +
 * "," + "-1" + "," + "-1" + "," + "-1" + "\n")
 * }
 * catch (e:NullPointerException)
 * {
 * info("NullPointerException from " + occurrence.source.UUID)
 * }
 */

