/** 
 * 
 */
package be.uclouvain.aptitude.agents.algorithm

import be.uclouvain.aptitude.agents.algorithm.util.BBOX
import be.uclouvain.aptitude.agents.algorithm.util.BBoxes2D
import be.uclouvain.aptitude.agents.algorithm.util.countingLine
import be.uclouvain.organisation.told.LeavePlatform
import io.sarl.core.Destroy
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import java.util.ArrayList
import java.util.TreeMap
import java.util.UUID
import org.arakhne.afc.math.geometry.d2.d.Point2d
import java.io.FileReader
import org.json.simple.JSONObject
import org.json.simple.parser.JSONParser;

/** 
 * @author manjah
 * 
 */
behavior CounterRole {
	uses Logging, ExternalContextAccess 

	
	protected var PlatformSpace : OpenEventSpace
	protected var PlatformID : UUID

	protected var ExpertID : UUID

	

	// Variables and code line for ObjectCounter :
	val countingLines : TreeMap<String, countingLine> = new TreeMap<String, countingLine>;

	val ObjectPresentInframe = new TreeMap<Integer, BBoxes2D>

	val ObjectToBeAnalyzed = new ArrayList<BBoxes2D>;

	// end
	on Initialize {
		info("Observer Role started" + occurrence.parameters.get(0).toString)
		countingLines.put("A", new countingLine(1235, 700, 309, 664, 1)) // ObjectCounter
		countingLines.put("B", new countingLine(1477, 324, 1676, 310, -1))
		// countingLines.put("B", new countingLine(1531, 392, 1775, 376, -1)) // ObjectCounter
		
		var l = parser.parse(new FileReader("S")) as JSONObject
	}

	on LeavePlatform {
		// join(BaseContext.ID, BaseSpace.spaceID.ID)
		info("ObserverLeaving")
		leave(PlatformID)
	}

	on BBoxes2DTrackResult {
		
		// println("***********************")
		// println("*  " + occurrence.bboxes2DTrack.frameNumber)
		// println("*  " + occurrence.bboxes2DTrack.trackingTime)
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.globalIDs))
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.bboxes))
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.classIDs))
		// println("*  " + Arrays.toString(occurrence.bboxes2DTrack.detConfs))
		// println("*  " + occurrence.bboxes2DTrack.lastFrame)
		// println("***********************")
		var ratio_width = 1920.0 / occurrence.bboxes2DTrack.dimWidth
		var ratio_height = 1080.0 / occurrence.bboxes2DTrack.dimHeight
		var frameNumber = occurrence.bboxes2DTrack.frameNumber

		ObjectToBeAnalyzed.clear

		for (var i = 0; i < occurrence.bboxes2DTrack.numberObjects; i++) {
			var X = occurrence.bboxes2DTrack.bboxes.get(4 * i) * ratio_width
			var Y = occurrence.bboxes2DTrack.bboxes.get(4 * i + 1) * ratio_height
			var W = occurrence.bboxes2DTrack.bboxes.get(4 * i + 2) * ratio_width
			var H = occurrence.bboxes2DTrack.bboxes.get(4 * i + 3) * ratio_height
			var classID = occurrence.bboxes2DTrack.classIDs.get(i)
			var globalID = occurrence.bboxes2DTrack.globalIDs.get(i)
			var conf = occurrence.bboxes2DTrack.detConfs.get(i)

			if (ObjectPresentInframe.containsKey(globalID)) {
				ObjectPresentInframe.get(globalID).update(X, Y, W, H, classID, frameNumber, conf)
			} else {
				ObjectPresentInframe.put(globalID,
					new BBoxes2D(new BBOX(X, Y, W, H), conf, globalID, classID, frameNumber))
			}

			ObjectToBeAnalyzed.add(ObjectPresentInframe.get(globalID))
		}
		attemp_count(new ArrayList(ObjectToBeAnalyzed))
		if (occurrence.bboxes2DTrack.lastFrame) {
			info("That was it! " )
			//val totalTime = (((System.currentTimeMillis() - this.start) / 1000))
			//info("It took " + totalTime.toString + " seconds")
			//info("Average FPS : " + (occurrence.bboxes2DTrack.frameNumber / totalTime).toString)
		}
	}

	// def has_crossed_counting_line(bbox, line){
	// } 
	
	def attemp_count(boundingBoxes : ArrayList<BBoxes2D>) {

		for (bb : boundingBoxes) {
			for (counting_line : countingLines.keySet) {
				if (has_crossed_counting_line(bb.getBBOX, countingLines.get(counting_line)) &&
					!countingLines.get(counting_line).ObjectEncountered(bb.globalID)) {
					val orientation = countingLines.get(counting_line).Orientation(bb.getDirection)
					var bbDir = bb.getDirection
					var nDir = countingLines.get(counting_line).getNormale
					if (orientation != 0) {
						info(
							"Counted at frame " + bb.frame + " and " + counting_line + " is : " +
								countingLines.get(counting_line).IncrementCounts() + " v=" + "(" + bbDir.x + " , " +
							bbDir.y + 
						 	"And n=" + "(" + nDir.getX + " , " + nDir.getY + ")" + " ori:" +
								orientation)
						}
					else {

						info(
							"ID :" + bb.globalID + " Counted Horizontally at the frame " + bb.frame + " at : " +
								counting_line + " v=" + "(" +
							 bbDir.x + " , " + bbDir.y + ")" + " and n=" + "(" + nDir.getX + "," + nDir.getY + ")" +
							" orientation:" + orientation)
					}
				}
			}
		}

	}

	def has_crossed_counting_line(b : BBOX, cl : countingLine) {

		val bbox_line1 : ArrayList<Point2d> = newArrayList(new Point2d(b.x, b.y), new Point2d(b.x + b.w, b.y)) // (x, y), (x + w, y)
		val bbox_line2 : ArrayList<Point2d> = newArrayList(new Point2d(b.x + b.w, b.y),
			new Point2d(b.x + b.w, b.y + b.h)); // = [(x + w, y), (x + w, y + h)]
		val bbox_line3 : ArrayList<Point2d> = newArrayList(new Point2d(b.x, b.y), new Point2d(b.x, b.y + b.h)); //= [(x, y), (x, y + h)]
		val bbox_line4 : ArrayList<Point2d> = newArrayList(new Point2d(b.x, b.y + b.h),
			new Point2d(b.x + b.w, b.y + b.h)); // [(x, y + h), (x + w, y + h)]
		if(line_segments_intersect(bbox_line1, cl.getLine) || line_segments_intersect(bbox_line2, cl.getLine) ||
			line_segments_intersect(bbox_line3, cl.getLine) || line_segments_intersect(bbox_line4, cl.getLine)) {
			return true
		}

		return false
	}

	def line_segments_intersect(line1 : ArrayList<Point2d>, line2 : ArrayList<Point2d>) {

		var p1 = line1.get(0)
		var q1 = line1.get(1)
		var p2 = line2.get(0)
		var q2 = line2.get(1)

		var o1 = get_orientation(p1, q1, p2)
		var o2 = get_orientation(p1, q1, q2)
		var o3 = get_orientation(p2, q2, p1)
		var o4 = get_orientation(p2, q2, q1)

		if (o1 != o2 && o3 != o4) {
			return true
		}
		if (o1 == 0 && is_on_segment(p1, p2, q1)) {

			return true
		}
		if (o2 == 0 && is_on_segment(p1, q2, q1)) {
			return true
		}
		if (o3 == 0 && is_on_segment(p2, p1, q2)) {
			return true
		}
		if (o4 == 0 && is_on_segment(p2, q1, q2)) {
			return true
		}
		return false

	}

	def get_orientation(p : Point2d, q : Point2d, r : Point2d) {

		val a = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)
		if (a == 0) {
			return 0
		} else if (a > 0) {
			return 1
		}
		return 2
	}

	def is_on_segment(p : Point2d, q : Point2d, r : Point2d) {
		if (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) &&
			q.y >= Math.min(p.y, r.y)) {
			return true
		}
		return false
	}

	on Destroy {
	}

}

/* Test
 * 
 * 
 * info(
 * " X:" + currentBB.get(0).getBBOX.getX + " Y:" + currentBB.get(0).getBBOX.getY + " W:" +
 * currentBB.get(0).getBBOX.getW + " H:" + currentBB.get(0).getBBOX.getH + "Conf:" +
 * currentBB.get(0).getConf + "ID: " + currentBB.get(0).getGlobalID)

 * info(" X:" + currentBB.get(1).getBBOX.getX + " Y:" + currentBB.get(1).getBBOX.getY + " W:" +
 * currentBB.get(1).getBBOX.getW + " H:" + currentBB.get(1).getBBOX.getH + "Conf:" +
 * currentBB.get(1).getConf + "ID: " + currentBB.get(1).getGlobalID)
 * info(
 * " X:" + currentBB.get(currentBB.size - 1).getBBOX.getX + " Y:" +
 * currentBB.get(currentBB.size - 1).getBBOX.getY + " W:" +
 * currentBB.get(currentBB.size - 1).getBBOX.getW + " H:" +
 * currentBB.get(currentBB.size - 1).getBBOX.getH + "Conf:" +
 * currentBB.get(currentBB.size - 1).getConf + "ID: " + currentBB.get(currentBB.size - 1).getGlobalID)
 */
