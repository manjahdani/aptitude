package be.uclouvain.organisation.platform

import be.uclouvain.organisation.events.SignalID
import be.uclouvain.organisation.platform.events.AddAlgorithm
import be.uclouvain.organisation.platform.events.AddMission
import be.uclouvain.organisation.platform.events.HyperParametersRequest
import be.uclouvain.organisation.platform.events.LeavePlatform
import be.uclouvain.organisation.platform.events.ProcessingHyperParameters
import be.uclouvain.organisation.platform.events.ResumeMission
import be.uclouvain.organisation.platform.util.SurveillanceMissionData
import io.sarl.core.Behaviors
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.core.Schedules
import java.util.Collections
import java.util.HashMap
import java.util.UUID

/** 
 * Receives data at a certain stage (Raw, Information, Knowledge, Insight) and process it. 
 * Observers are distinct if they process a different Signal or use another Model or both .
 * 
 * It Becomes a multi-layer concept if it involves several entities observing the same target(data).
 * A possible Holonic configuration could have the following layers : 
 * 
 * 			- Multiple Sensors at different location analysing the same scene
 *          - Multiple Algorithms with different beliefs analysing the same signal. 
 * 
 * Example : let's take a junction equipped with three cameras (C_1  ,C_2,C_3) aiming to provide a list of the cars in the scene. 
 * The cameras dispose two algorithms models (M_1 ,M_2). Let us assume, that C_1  uses M_1and M_2 to process the data while others only use M_1. 
 * You have four Observers (O_1,O_2,O_3,O_4) = (C_1 M_1; C_1 M_2; C_2 M_1; C_3 M_1). 
 * A stable and scalable approach would consider two supplementary Observers to gather this as a Holonic system. 
 * On the one hand an Observer O_5 concatenating the perceptions of O_1, O_2 and on the other hand, a sixth Observer for the perceptions of O_5 O_3 O_4. 
 * Notice that Observers O_1and O_2 became Signals for O_5, becoming itself a signal for O_6. 
 * 
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $organisation$
 */
 
abstract behavior ObserverRole extends ScenarioRole {
	
	uses Logging, Behaviors, ExternalContextAccess, Schedules

	protected val providers = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the role and data providers
	//protected var processingParameters = Collections.synchronizedMap(new HashMap<UUID, HyperParameters>) // 
	protected val orderedMissionList = Collections.synchronizedMap(new HashMap<UUID, SurveillanceMissionData>) // A map between mission ID that it ordered to another observer and their data
	
	
	on HyperParametersRequest {

		// We decide that derived role handles the parameters request of inner-agents.
		// Removing the flag results in nullException as the role
		// receives a request from a innerAgent but did not include it in its providers.
		var providerID = occurrence.source.ID
		// info("Param requests from agentID :=" + providerID.toString.substring(0, 5))
		val MD = orderedMissionList.get(occurrence.missionID)
		info(
			"Transmit |param{s= " + MD.cautionLevel + " dynamicAdaptation=" + MD.isDynamicAdaptationEnabled +
				"}|mID = " +MD.missionID.toString.substring(0,5) + " to " + providerID.toString.substring(0, 5))
		emit(providers.get(providerID), new ProcessingHyperParameters(
			occurrence.missionID, orderedMissionList.get(occurrence.missionID).hyperParameters))[it.ID == providerID]
	}
	on SignalID {
		
		val signalID = occurrence.signalID
		val mID= occurrence.missionID
		
		if(!providers.containsKey(signalID)){
			orderedMissionList.get(mID).signalID = signalID
			// create a new private communication space between the signal and observer and listen to it
			val sID = UUID.randomUUID
			val comSpace = organizationContext.get.getOrCreateSpaceWithID(OpenEventSpaceSpecification,
				sID)
			comSpace.registerStrongParticipant(asEventListener)
			providers.put(signalID, comSpace)
			//info("Received provider ID sending sid " + comSpace.spaceID.ID)
			emit(organizationContext.get.defaultSpace, new AddMission(occurrence.missionID, sID)) [
				it.ID == signalID
			]
		}
		else{
			info("Known signal = " + signalID)
			emit(providers.get(signalID),new ResumeMission(mID, true))[it.ID == signalID]
		}
	}

	on LeavePlatform {
		// join(BaseContext.ID, BaseSpace.spaceID.ID)
		// info("Detector Leaving")
		
		// leave(PlatformID)
	}
	

	
	on RecruitSignal {
		
		orderedMissionList.put(occurrence.missionData.missionID, occurrence.missionData)
		if (privateOrganizationSpace.get !== null) {
			requestAlgorithm(occurrence.missionData.missionID, occurrence.task)
		}
		else{
			task("recuitSignal".concat(occurrence.missionData.missionID.toString)).every(100) [
				if (privateOrganizationSpace.get !== null) {
					requestAlgorithm(occurrence.missionData.missionID, occurrence.task)
					task("recuitSignal".concat(occurrence.missionData.missionID.toString)).cancel
				}
				else{
					info("trying to recruit but no platform")
				}
			]
		}
		processingMissionWithID(occurrence.missionData.missionID)
	}

	on ProcessMission{

		missionList.put(occurrence.missionData.missionID, occurrence.missionData)
		processingMissionWithID(occurrence.missionData.missionID)
	}

	def requestAlgorithm(mID : UUID, algoTask : String) {

		info("Observer recruits request t = " + algoTask)
		emit(privateOrganizationSpace.get, new AddAlgorithm(mID, algoTask))
	}
}


