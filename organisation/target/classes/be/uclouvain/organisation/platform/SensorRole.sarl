/** 
 * 
 */
package be.uclouvain.organisation.platform

import be.uclouvain.organisation.platform.events.AddMission
import be.uclouvain.organisation.platform.events.HyperParametersRequest
import be.uclouvain.organisation.platform.events.ProcessingHyperParameters
import be.uclouvain.organisation.platform.util.SurveillanceMissionData
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.Schedules
import java.util.Collections
import java.util.HashMap
import java.util.UUID
import java.util.ArrayList
import io.sarl.core.Behaviors

/** 
 * @author manjah
 * 
 */
abstract behavior SensorRole extends ScenarioRole {
	uses Logging, Schedules, ExternalContextAccess, Behaviors

	protected val listeners = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the client and the role
	protected val missionList = Collections.synchronizedMap(new HashMap<UUID, SurveillanceMissionData>) // A map between mission ID that it needs to answer to and their data
	on ProcessingHyperParameters {
		info("param received " + "MID = " + occurrence.missionID + " hp " + occurrence.param.hyperParametersAsAString)
		missionList.get(occurrence.missionID).update(occurrence.param)
	}

	on AddMission {

		val missionSpace = retrieveOrCreateOpenSpaceWithID(occurrence.communicationChannelID)
		val clientID = occurrence.source.ID
		val missionID = occurrence.missionID
		info("received mission request from "  + clientID + "\n sid = " + missionSpace.spaceID.ID + "\n mID = " + missionID )
		var accepted = true // @TODO LOW develop criteria for the admission of the mission
		if (accepted) {
			val newMission = new SurveillanceMissionData(missionID, clientID, organizationContext.get.ID)
			missionList.put(occurrence.missionID, newMission)
			listeners.put(clientID, missionSpace)
			missionSpace.registerStrongParticipant(asEventListener)
			waitMissionParam(occurrence.missionID)
			emit(missionSpace, new HyperParametersRequest(occurrence.missionID))[it.ID == clientID]
		}
	}
	
	//@FIXME LOW the setup is here as at a higher level, there is no possibly to have another name than observer which trigers the same 
	// maybe it is possible to improve that 
	def setup() {
		info("setup of the role sensor agent")
		task("initSen").every(1000) [
			if (areAllTrue(checkList.values)) {
				startRole()
				task("initSen").cancel
			} else {
				info("Waiting for orga and ressources" + checkList)
			}
		]
	}
	
	def waitMissionParam(mID : UUID) {

		task("rMP".concat(mID.toString)).every(1000) [
			val MD = missionList.get(mID)
			if (MD.hyperParameters.paramKnown) {
				info("Start the processing role for mid = " + mID+ "\n at location - " + ". Parameters are: s= " + MD.cautionLevel +
						" isMaster=" + MD.isDynamicAdaptationEnabled)
				processingMissionWithID(mID)
				loggingName = this.ID + "-ALGORITHM-" + ADN.get.name + "-" + ADN.get.level + "-" +
					ADN.get.platformName + "-" + computation_location
				task("rMP".concat(mID.toString)).cancel
			} else {
				info("Waiting for command MID = " + mID + " hp " + MD.hyperParametersAsAString)
			}
		]
	}

	abstract def processingMissionWithID(mID : UUID)

	def enableDataAcquisition(mID : UUID, signals : ArrayList<String>, signalType : String) {

		for (s : signals) {

			info("Request " + s + " as " + signalType)
			emit(selfSpace, new RecruitSignal(missionList.get(mID), s, signalType))
		}
	}
}
