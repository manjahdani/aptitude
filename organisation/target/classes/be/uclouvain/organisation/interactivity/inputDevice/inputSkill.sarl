/** 
 * 
 */
package be.uclouvain.organisation.interactivity.inputDevice

import io.sarl.core.Schedules
import io.sarl.lang.core.EventSpace
import java.io.IOException
import java.net.DatagramPacket
import java.net.DatagramSocket
import java.net.SocketException
import java.util.TreeMap
import java.util.UUID
import UDPMessages.MessageDeserializer
import UDPMessages.UDP_Message_Base

/** 
 * @author manjah
 * 
 */
abstract skill InputSkill implements InputDeviceCapacity {
	uses Schedules

	val client : DatagramSocket;
	protected var listenersSpaceIDs : TreeMap<UUID, EventSpace>

	protected var serverRunning : boolean = true;
	var parser = new MessageDeserializer();

	def synchronized EnableInputStream() {
		val Enable_Server = task("Enable_Server")
		Enable_Server.execute([
			try {
				while (!isCanceled(Enable_Server) && !client.isClosed) {
					var buffer = newByteArrayOfSize(8192);
					var packet = new DatagramPacket(buffer, buffer.length);
					client.receive(packet)
					var message = new String(packet.getData(), packet.getOffset(), packet.getLength());
					var data = parser.Deserialize(message); // To change, it seems weird, there's a conflict between this and the role of an element
					MessageAnalysis(data, packet.getAddress().getHostAddress)
					packet.setLength(buffer.length);
				}
				client.close();
			} catch (e : SocketException) {
				e.printStackTrace();
			} catch (e : IOException) {
				e.printStackTrace();
			}
		])
	}

	def synchronized uninstall {
	}

	def synchronized DisableInputStream {
		this.client.close()
		task("Enable_Server").cancel

	}

	abstract def MessageAnalysis(data : UDP_Message_Base, IPaddrs : String)

	new (p : int) {
		this.client = new DatagramSocket(p)
	}

	new (p : int, subWorldSpaceIDs : TreeMap<UUID, EventSpace>) {
		this.client = new DatagramSocket(p)
		this.listenersSpaceIDs = subWorldSpaceIDs
	}

	new (server : DatagramSocket) {
		this.client = server
	}
}
