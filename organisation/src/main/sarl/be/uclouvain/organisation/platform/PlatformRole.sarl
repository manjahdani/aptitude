/** 
 */
package be.uclouvain.organisation.platform

import be.uclouvain.organisation.AuthorizationToJoinContext
import be.uclouvain.organisation.PlatformOrganisationInfo
import be.uclouvain.organisation.RequestToJoin
import be.uclouvain.organisation.TOLDOrganisationInfo
import io.sarl.core.Behaviors
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import java.util.HashMap
import java.util.UUID
import java.util.concurrent.atomic.AtomicReference
import be.uclouvain.organisation.AuthorizationToPerformMission

/** 
 * The Platform manages the storage and/or computing of resources. A Platform could include sub-Platforms (holonic). 
 * At the top level, the role manages the resources from a holistic perspective. At the lower level, the role manages directly the hardware.
 *
 * As an example, a city-scale network of cameras remains a Platform that could be divided into
 * sub-Platforms; namely the level of crossroads. Likewise, the level could be divided again to reach
 * the atomic level of the hardware consisting of a camera and a processor.
 * 
 * @FIXME : Check whether it makes sens the use of OpenEvent rather than EvenSpecification. 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.3$
 * @date $11/06/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $organisation$
 *   
 */


behavior PlatformRole {
	uses Behaviors, InnerContextAccess, ExternalContextAccess, Logging

	protected var TOLDID : UUID
	protected val privateSpacesListeners = new HashMap<UUID, OpenEventSpace>
	protected val missionSpace = new HashMap<UUID, OpenEventSpace> // Used for the communications among observers.
	val location = new AtomicReference<String>
	
	@SuppressWarnings("potential_field_synchronization_problem")
	on Initialize {
		location.set(occurrence.parameters.get(0).toString)
	}

	@SuppressWarnings("potential_field_synchronization_problem")
	on TOLDOrganisationInfo {
		TOLDID = occurrence.source.UUID
		info("met TOLD organisation - " + TOLDID.toString.substring(0, 5))
		if (!privateSpacesListeners.containsKey(TOLDID)) { // Not Encountered
			info("TOLD was not encountered")
			privateSpacesListeners.put(TOLDID, occurrence.privateCommunicationChannel)
			occurrence.privateCommunicationChannel.register(asEventListener)
			occurrence.privateCommunicationChannel.emit(
				new PlatformOrganisationInfo(innerContext, privateSpacesListeners.get(TOLDID), location.get)) [
				it.UUID == TOLDID
			]
		//PlatformTOLDSpace.register(asEventListener)
		//PlatformTOLDSpace.emit(new JoinOrganisation(innerContext))
	}}

	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on AddMission {
		// RuleManagement(new MembershipInfoRule(occurrence.source, occurrence.SourceEventSpace, occurrence.entityData))
		// if (true) {
		
		info("Received the request to add a mission " + occurrence.source.UUID + occurrence.MissionData.location)
		
		missionSpace.put(occurrence.MissionData.missionID,
			innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, occurrence.MissionData.missionID))
		emit(
			occurrence.SourceEventSpace,
			new AuthorizationToPerformMission(missionSpace.get(occurrence.MissionData.missionID))
		)[it.UUID == occurrence.source.getUUID]
	}
	
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	
	on RequestToJoin {
		info("receives a request to welcome a new agent")
		occurrence.emitterSpace.emit(this.ID, 
			new AuthorizationToJoinContext(this.ID, innerContext.defaultSpace.spaceID.ID)) [
				it.UUID == occurrence.source.getUUID
			]
	}
	
	on MemberJoined {

		val memberID = occurrence.agentID
		privateSpacesListeners.put(memberID,
			innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID))
		privateSpacesListeners.get(memberID).register(asEventListener)
		
		sendOrganisationinfo(memberID);
	}
	on StopMission {
		// if(RuleManagement())
		info(" I received a Stop Misson" + occurrence.expertID)
		wake(new LeavePlatform)
	}
	
	def sendOrganisationinfo(memberID : UUID) {
		info("sending organisation info - " + memberID.toString.substring(0, 5))
		wake(new PlatformOrganisationInfo(innerContext, privateSpacesListeners.get(memberID), location.get)) [
			it.UUID == memberID
		]
	}
}



