/** 
 */
package be.uclouvain.organisation.platform

import be.uclouvain.organisation.Identification
import be.uclouvain.organisation.PlatformOrganisationInfo
import be.uclouvain.organisation.TOLDOrganisationInfo
import be.uclouvain.organisation.told.util.AlgorithmInfo
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.core.Schedules
import io.sarl.lang.core.AgentContext
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger

/** 
 * Receives data at a certain stage (Raw, Information, Knowledge, Insight) and process it. 
 * Observers are distinct if they process a different Signal or use another Model or both .
 * 
 * It Becomes a multi-layer concept if it involves several entities observing the same target(data).
 * A possible Holonic configuration could have the following layers : 
 * 
 * 			- Multiple Sensors at different location analysing the same scene
 *          - Multiple Algorithms with different beliefs analysing the same signal. 
 * 
 * Example : let's take a junction equipped with three cameras (C_1  ,C_2,C_3) aiming to provide a list of the cars in the scene. 
 * The cameras dispose two algorithms models (M_1 ,M_2). Let us assume, that C_1  uses M_1and M_2 to process the data while others only use M_1. 
 * You have four Observers (O_1,O_2,O_3,O_4) = (C_1 M_1; C_1 M_2; C_2 M_1; C_3 M_1). 
 * A stable and scalable approach would consider two supplementary Observers to gather this as a Holonic system. 
 * On the one hand an Observer O_5 concatenating the perceptions of O_1, O_2 and on the other hand, a sixth Observer for the perceptions of O_5 O_3 O_4. 
 * Notice that Observers O_1and O_2 became Signals for O_5, becoming itself a signal for O_6. 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $organisation$
 */
 
abstract behavior ObserverRole {
	
	uses Logging, Behaviors, DefaultContextInteractions, InnerContextAccess, ExternalContextAccess, Schedules

	protected var privateTOLDSpace : OpenEventSpace
	protected var TOLDContext : AgentContext
	protected var privatePlatformSpace : OpenEventSpace
	protected var platformContext : AgentContext
	protected var selfSpace : OpenEventSpace = innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification,
		UUID.randomUUID)// An internal space to communicate with other roles. 
	protected var sensitivity = new AtomicInteger()
	protected var observerADN : AlgorithmInfo	
	protected var isMaster  = new AtomicBoolean(false)
	protected val listeners = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the client and the role 
	protected val providers = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the role and data providers
	protected var platformName : String
	protected var computation_location : String
	
	protected var checkList = Collections.synchronizedMap(new HashMap<String, Boolean>)
	
	protected var processingParameters = new ArrayList<String>
	
	@SuppressWarnings("potential_field_synchronization_problem")
	on Initialize {

		observerADN = occurrence.parameters.get(0) as AlgorithmInfo
		selfSpace.registerStrongParticipant(asEventListener) // Listen to a self-internal space
		
		providers.put(observerADN.ID, selfSpace)
		listeners.put(observerADN.ID, selfSpace) // // Listen to its own results To send results to itself @FIXME maybe we could just program a flag.. as it is not needed everywhere
		checkList.put("isCompLocationKnown", false)
		checkList.put("paramKnown", false)
		task("waiting-greenLights").every(1000)[
			if (areAllTrue(checkList.values)) {
				info("Start the processing role at location - "+computation_location+". Parameters are: s= "+sensitivity.get+ " isMaster=" + isMaster.get)
				startProcessingRole
				task("waiting-greenLights").cancel
			}
			else{
				debug("Waiting for command" + checkList)
			}
		]
	}

	on HyperParametersRequest {
		
		var providerID = occurrence.source.ID
		// We decide that derived role handles the parameters request of inner-agents. 
		//Removing the flag results in nullException as the role 
		//receives a request from a innerAgent but did not include it in its providers.
		
		if(!getMemberAgents.contains(providerID)){
		info("param requests from agentID=" + providerID.toString.substring(0, 5) +
				" sending param:" + " s =" +sensitivity)
		providers.get(providerID).emit(
				observerADN.ID, 
			new ProcessingHyperParameters(sensitivity.get, isMaster.get)
		) [it.ID == providerID]}
		
	}
	on Destroy {
		//info("The behavior was stopped.")
}
	on ComputationalRessources {
		debug("received computation_location: " + occurrence.client_id)
		computation_location = occurrence.client_id
		checkList.put("isCompLocationKnown",true)
	}

	@SuppressWarnings("potential_field_synchronization_problem")
	on PlatformOrganisationInfo  { 
		platformContext = occurrence.context
		privatePlatformSpace = occurrence.privateCommunicationChannel
		privatePlatformSpace.registerStrongParticipant(asEventListener)
		platformName = occurrence.platformName
		observerADN.platformName = occurrence.platformName
		emit(platformContext.defaultSpace,new Identification(observerADN.name)) //@ FIXME not general in the sens of it should whenever it joins a context
	}	
	
	on TOLDOrganisationInfo {
		TOLDContext = occurrence.context
		privateTOLDSpace = occurrence.privateCommunicationChannel
		privateTOLDSpace.registerStrongParticipant(asEventListener)
	}

	@SuppressWarnings("potential_field_synchronization_problem")
	
	on AddMission {

		occurrence.communicationChannel.registerStrongParticipant(asEventListener)
		var missionSpace = occurrence.communicationChannel
		var clientID = occurrence.source.ID
		
		info("requested to add mission with ID = " + (missionSpace.spaceID.toString.substring(0, 5)) + " from " +
			clientID.toString.substring(0, 5))
		listeners.put(clientID, missionSpace) // @FIXME maybe there is a huge misunderstanding of the use of Spaces, maybe we could have address which is simpler
		var accepted = true // @TODO develop criteria for the admission of the mission 
		if (accepted) {
			missionSpace.emit(observerADN.ID, new HyperParametersRequest)[it.ID == clientID]
			debug("requests missionParameters to " + clientID.toString.substring(0,5))
			}
	}
	@SuppressWarnings("potential_field_synchronization_problem")
	on StopMission {
		if (listeners.keySet.contains(occurrence.source.ID)){
			info("I received the StopMission")
			emit(new StopMission(occurrence.expertID))
			emit(new LeavePlatform)[it.ID == observerADN.ID] 
		}
	}
		@SuppressWarnings("potential_field_synchronization_problem")
		on LeavePlatform {
		//join(BaseContext.ID, BaseSpace.spaceID.ID)
		//info("ObserverLeaving")
		//leave(PlatformContext.ID)
	}
	on ProcessingHyperParameters {		
		sensitivity.set(occurrence.s)
		isMaster.set(occurrence.OptimalSearchEnabled)
		processingParameters.add(sensitivity.toString)
		checkList.put("paramKnown",true)
	}


	synchronized def requestAlgorithm(algoName : String, algoTask : String) {
		privatePlatformSpace.emit(new AddObserver(
			new AlgorithmInfo(algoName, algoTask),
			new AlgorithmInfo(observerADN.name, observerADN.task)
		))[it.ID == platformContext.ID]
	}
	
	abstract def startProcessingRole()

 	synchronized def areAllTrue(array: boolean[]) {
 		for(b : array) if(!b) return false;
    	return true;
    }
}


