package be.uclouvain.organisation.platform

import be.uclouvain.organisation.Role
import be.uclouvain.organisation.events.Identification
import be.uclouvain.organisation.events.SignalID
import be.uclouvain.organisation.platform.events.AddMission
import be.uclouvain.organisation.platform.events.AddObserver
import be.uclouvain.organisation.platform.events.ComputationalRessources
import be.uclouvain.organisation.platform.events.HyperParametersRequest
import be.uclouvain.organisation.platform.events.LeavePlatform
import be.uclouvain.organisation.platform.events.ProcessingHyperParameters
import be.uclouvain.organisation.platform.events.ResumeMission
import be.uclouvain.organisation.platform.events.StopMission
import be.uclouvain.organisation.platform.util.SurveillanceMissionData
import be.uclouvain.organisation.told.util.AlgorithmInfo
import io.sarl.core.Behaviors
import io.sarl.core.Destroy
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.core.Schedules
import java.util.Collections
import java.util.HashMap
import java.util.UUID
import java.util.concurrent.atomic.AtomicReference
import be.uclouvain.organisation.platform.util.HyperParameters

/** 
 * Receives data at a certain stage (Raw, Information, Knowledge, Insight) and process it. 
 * Observers are distinct if they process a different Signal or use another Model or both .
 * 
 * It Becomes a multi-layer concept if it involves several entities observing the same target(data).
 * A possible Holonic configuration could have the following layers : 
 * 
 * 			- Multiple Sensors at different location analysing the same scene
 *          - Multiple Algorithms with different beliefs analysing the same signal. 
 * 
 * Example : let's take a junction equipped with three cameras (C_1  ,C_2,C_3) aiming to provide a list of the cars in the scene. 
 * The cameras dispose two algorithms models (M_1 ,M_2). Let us assume, that C_1  uses M_1and M_2 to process the data while others only use M_1. 
 * You have four Observers (O_1,O_2,O_3,O_4) = (C_1 M_1; C_1 M_2; C_2 M_1; C_3 M_1). 
 * A stable and scalable approach would consider two supplementary Observers to gather this as a Holonic system. 
 * On the one hand an Observer O_5 concatenating the perceptions of O_1, O_2 and on the other hand, a sixth Observer for the perceptions of O_5 O_3 O_4. 
 * Notice that Observers O_1and O_2 became Signals for O_5, becoming itself a signal for O_6. 
 * 
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $organisation$
 */
 
abstract behavior ObserverRole extends Role {
	
	uses Logging, Behaviors, InnerContextAccess, ExternalContextAccess, Schedules

	protected var observerADN = new AtomicReference<AlgorithmInfo>
	protected val selfSpace : OpenEventSpace = innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID) // An internal space to communicate with other roles.
	protected val missionList = Collections.synchronizedMap(new HashMap<UUID, SurveillanceMissionData>) // The one it has to answer to 
	protected val listeners = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the client and the role
	
	protected val providers = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the role and data providers
	protected var processingParameters = Collections.synchronizedMap(new HashMap<UUID, HyperParameters>) // One that it ordered. 
	protected var computation_location = new AtomicReference<String>
	val checkList = Collections.synchronizedMap(new HashMap<String, Boolean>)

	on Initialize {
		observerADN.set(occurrence.parameters.get(0) as AlgorithmInfo)
		selfSpace.registerStrongParticipant(asEventListener) // listen to a self-internal space
		checkList.put("context", false)
		checkList.put("computation_location", false)
	}
	
	def setup(){
		info("setup of the agent")
		task("init").every(1000) [
			if(areAllTrue(checkList.values)){
				startRole()
				task("init").cancel
			}
			else{
				debug("Waiting for orga and ressources"+checkList)
			}
		]
	}
	on HyperParametersRequest {
		
		var providerID = occurrence.source.ID
		// We decide that derived role handles the parameters request of inner-agents. 
		//Removing the flag results in nullException as the role 
		//receives a request from a innerAgent but did not include it in its providers.
		
		if(!getMemberAgents.contains(providerID)){
			var MD = processingParameters.get(occurrence.missionID)
			debug("param requests from agentID=" + providerID.toString.substring(0, 5) +
				" sending param:" + " s =" + MD.cautionLevel)
				
			emit(providers.get(providerID), new ProcessingHyperParameters(occurrence.missionID,processingParameters.get(occurrence.missionID))
			)[it.ID == providerID]
		}
		
	}
	on Destroy {
		//info("The behavior was stopped.")
}
	on ComputationalRessources {
		info("received computation_location: " + occurrence.client_id)
		computation_location.set(occurrence.client_id)
		checkList.put("computation_location",true)
	}


	on PlatformOrganizationInfo {
	
		updateContextInfo(occurrence.context, occurrence.privateCommunicationChannelID)
		emit(organizationContext.get.defaultSpace, new Identification(getName()))
		observerADN.get.platformName = occurrence.platformName
		checkList.put("context",true)
	}	
	
	on AddMission {

		val missionSpace = retrieveOrCreateOpenSpaceWithID(occurrence.communicationChannelID)
		var clientID = occurrence.source.ID
		
		var accepted = true // @TODO LOW develop criteria for the admission of the mission 
		if (accepted) {
			val newMission = new SurveillanceMissionData(occurrence.missionID, 
				clientID, organizationContext.get.ID)
			missionList.put(occurrence.missionID,newMission)
			listeners.put(clientID, missionSpace)
			waitMissionParam(occurrence.missionID)
			emit(missionSpace,new HyperParametersRequest(occurrence.missionID))[it == occurrence.source]
	}}
	
	
	def waitMissionParam(mID : UUID) {

		task("rMP".concat(mID.toString)).every(1000) [
			if (missionList.get(mID).hyperParameters.paramKnown) {
				
				var MD = missionList.get(mID)
				info(
					"Start the processing role at location - " + ". Parameters are: s= " +
						MD.cautionLevel + " isMaster=" + MD.isDynamicAdaptationEnabled)
				processingMissionWithID(mID)
				loggingName = this.ID + "-ALGORITHM-" + observerADN.get.name + "-" + observerADN.get.level + "-" + observerADN.get.platformName +
					"-" + computation_location
				task("waiting-greenLights").cancel
			} else {
				info("Waiting for command" + mID + computation_location)
			}
		]
	}
	 
	
	on StopMission {
		if (listeners.keySet.contains(occurrence.source.ID)){
			info("I received the StopMission")
			listeners.remove(occurrence.source.ID)
		}
		else{
			info("I do not recognize the provider" + occurrence.expertID)
		}
	}
	on LeavePlatform {
		//join(BaseContext.ID, BaseSpace.spaceID.ID)
		//info("ObserverLeaving")
		//leave(PlatformContext.ID)
	}
	on ProcessingHyperParameters {
		missionList.get(occurrence.missionID).update(occurrence.param)
	}

	
	on SignalID {
		
		var signalID = occurrence.signalID
		val missionID= occurrence.missionID
		
		if(!providers.containsKey(signalID)){
			// info("Unkown signal" + sid)
			// @FIXME MEDIUM we have to ask for MISSION
			val comChannel = organizationContext.get.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID)
			comChannel.registerStrongParticipant(asEventListener)
			providers.put(signalID, comChannel)
			var hp_mission = missionList.get(missionID).hyperParameters // We add the Hyperparameters that we are going to provide later to the provider
			processingParameters.put(signalID, hp_mission)
			info("Received provider ID sending the channel " + providers.get(signalID).spaceID.ID)
			emit(organizationContext.get.defaultSpace,new AddMission(occurrence.missionID, providers.get(signalID).spaceID.ID)) [it.ID == signalID]
		}
		else{
			info("Known signal = " + signalID)
			emit(providers.get(signalID),new ResumeMission)[this.ID == signalID]
			info("Trying now in the default")
			emit(organizationContext.get.defaultSpace,new ResumeMission)[it.ID==signalID]
		}
	}
	
	def getName : String{
		return observerADN.get.name
	}
	def requestAlgorithm(mID : UUID, algoName : String, algoTask : String) {
		
		emit(privateOrganizationSpace.get, new AddObserver(
			mID,
			new AlgorithmInfo(algoName, algoTask),
			new AlgorithmInfo(observerADN.get.name, observerADN.get.task)
		))[it.ID == organizationContext.get.ID]
	}
	
 	def areAllTrue(array: boolean[]) {
 		for(b : array) if(!b) return false;
    	return true;
    }

	abstract def startRole()
	abstract def processingMissionWithID(mID : UUID)
}


