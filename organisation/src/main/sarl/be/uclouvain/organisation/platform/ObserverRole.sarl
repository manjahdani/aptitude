package be.uclouvain.organisation.platform

import be.uclouvain.organisation.events.SignalID
import be.uclouvain.organisation.platform.events.AddMission
import be.uclouvain.organisation.platform.events.AddObserver
import be.uclouvain.organisation.platform.events.HyperParametersRequest
import be.uclouvain.organisation.platform.events.ProcessingHyperParameters
import be.uclouvain.organisation.platform.events.ResumeMission
import be.uclouvain.organisation.platform.util.SurveillanceMissionData
import be.uclouvain.organisation.told.util.AlgorithmInfo
import io.sarl.core.Behaviors
import io.sarl.core.ExternalContextAccess
import io.sarl.core.InnerContextAccess
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.core.Schedules
import java.util.Collections
import java.util.HashMap
import java.util.UUID

/** 
 * Receives data at a certain stage (Raw, Information, Knowledge, Insight) and process it. 
 * Observers are distinct if they process a different Signal or use another Model or both .
 * 
 * It Becomes a multi-layer concept if it involves several entities observing the same target(data).
 * A possible Holonic configuration could have the following layers : 
 * 
 * 			- Multiple Sensors at different location analysing the same scene
 *          - Multiple Algorithms with different beliefs analysing the same signal. 
 * 
 * Example : let's take a junction equipped with three cameras (C_1  ,C_2,C_3) aiming to provide a list of the cars in the scene. 
 * The cameras dispose two algorithms models (M_1 ,M_2). Let us assume, that C_1  uses M_1and M_2 to process the data while others only use M_1. 
 * You have four Observers (O_1,O_2,O_3,O_4) = (C_1 M_1; C_1 M_2; C_2 M_1; C_3 M_1). 
 * A stable and scalable approach would consider two supplementary Observers to gather this as a Holonic system. 
 * On the one hand an Observer O_5 concatenating the perceptions of O_1, O_2 and on the other hand, a sixth Observer for the perceptions of O_5 O_3 O_4. 
 * Notice that Observers O_1and O_2 became Signals for O_5, becoming itself a signal for O_6. 
 * 
 * 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $organisation$
 */
 
abstract behavior ObserverRole extends ScenarioRole {
	
	uses Logging, Behaviors, ExternalContextAccess, Schedules

	protected val providers = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the role and data providers
	//protected var processingParameters = Collections.synchronizedMap(new HashMap<UUID, HyperParameters>) // 
	protected val orderedMissionList = Collections.synchronizedMap(new HashMap<UUID, SurveillanceMissionData>) // A map between mission ID that it ordered to another observer and their data
	
	on HyperParametersRequest {

		// We decide that derived role handles the parameters request of inner-agents.
		// Removing the flag results in nullException as the role
		// receives a request from a innerAgent but did not include it in its providers.
		var providerID = occurrence.source.ID
		info("param requests from agentID=" + providerID.toString.substring(0, 5)) 
		var MD = orderedMissionList.get(occurrence.missionID)

		info("sending param" + " s =" + MD.cautionLevel)
		emit(providers.get(providerID), new ProcessingHyperParameters(
			occurrence.missionID, orderedMissionList.get(occurrence.missionID).hyperParameters))[it.ID == providerID]
	}
	on SignalID {
		
		var signalID = occurrence.signalID
		val missionID= occurrence.missionID
		
		if(!providers.containsKey(signalID)){
			orderedMissionList.get(missionID).signalID = signalID
			// create a new private communication space between the signal and observer and listen to it
			val comSpace = organizationContext.get.getOrCreateSpaceWithID(OpenEventSpaceSpecification,
				UUID.randomUUID)
			comSpace.registerStrongParticipant(asEventListener)
			providers.put(signalID, comSpace)
			info("Received provider ID sending sid " + comSpace.spaceID.ID)
			emit(organizationContext.get.defaultSpace, new AddMission(occurrence.missionID, comSpace.spaceID.ID)) [
				it.ID == signalID
			]
		}
		else{
			//@FIXME HIGH N'imp
			info("Known signal = " + signalID)
			emit(providers.get(signalID),new ResumeMission)[this.ID == signalID]
			info("Trying now in the default")
			emit(organizationContext.get.defaultSpace,new ResumeMission)[it.ID==signalID]
		}
	}


	// @FIXME LOW the setup is here as at a higher level, there is no possibly to have another name than observer which trigers the same
	// maybe it is possible to improve that
	def setup() {
		info("setup of the role observer agent")
		task("initObs").every(1000) [
			if (areAllTrue(checkList.values)) {
				startRole()
				task("initObs").cancel
			} else {
				info("Waiting for orga and ressources" + checkList)
			}
		]
	}
	

	
	on RecruitSignal {
		info("Observer recruits request for name = " + occurrence.name + " t = " + occurrence.task)
		val mission = occurrence.missionData
		orderedMissionList.put(mission.missionID, mission)
		requestAlgorithm(mission.missionID,occurrence.name,occurrence.task)
	}

	def requestAlgorithm(mID : UUID, algoName : String, algoTask : String) {
		
		emit(privateOrganizationSpace.get, new AddObserver(
			mID,
			new AlgorithmInfo(algoName, algoTask),
			new AlgorithmInfo(ADN.get.name, ADN.get.task)
		))[it.ID == organizationContext.get.ID]
	}
}


