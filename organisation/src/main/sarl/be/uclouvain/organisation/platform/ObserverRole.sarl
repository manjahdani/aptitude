package be.uclouvain.organisation.platform

import be.uclouvain.organisation.Identification
import be.uclouvain.organisation.SignalID
import be.uclouvain.organisation.told.util.AlgorithmInfo
import io.sarl.core.Behaviors
import io.sarl.core.Destroy
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import io.sarl.core.Schedules
import io.sarl.lang.core.AgentContext
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.UUID
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import be.uclouvain.organisation.told.TOLDOrganizationInfo

/** 
 * Receives data at a certain stage (Raw, Information, Knowledge, Insight) and process it. 
 * Observers are distinct if they process a different Signal or use another Model or both .
 * 
 * It Becomes a multi-layer concept if it involves several entities observing the same target(data).
 * A possible Holonic configuration could have the following layers : 
 * 
 * 			- Multiple Sensors at different location analysing the same scene
 *          - Multiple Algorithms with different beliefs analysing the same signal. 
 * 
 * Example : let's take a junction equipped with three cameras (C_1  ,C_2,C_3) aiming to provide a list of the cars in the scene. 
 * The cameras dispose two algorithms models (M_1 ,M_2). Let us assume, that C_1  uses M_1and M_2 to process the data while others only use M_1. 
 * You have four Observers (O_1,O_2,O_3,O_4) = (C_1 M_1; C_1 M_2; C_2 M_1; C_3 M_1). 
 * A stable and scalable approach would consider two supplementary Observers to gather this as a Holonic system. 
 * On the one hand an Observer O_5 concatenating the perceptions of O_1, O_2 and on the other hand, a sixth Observer for the perceptions of O_5 O_3 O_4. 
 * Notice that Observers O_1and O_2 became Signals for O_5, becoming itself a signal for O_6. 
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $organisation$
 */
 
abstract behavior ObserverRole {
	
	uses Logging, Behaviors, InnerContextAccess, ExternalContextAccess, Schedules

	protected var TOLDContext : AgentContext // context of the organisation TOLD
	protected var privateTOLDSpace : OpenEventSpace // private space between the algorithm and the organisation TOLD
	protected var platformContext : AgentContext // context of the organisation Platform
	protected var privatePlatformSpace : OpenEventSpace // private space between the algorithm and the organisation Platform 
	
	
	protected var selfSpace : OpenEventSpace = innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification,
		UUID.randomUUID)// An internal space to communicate with other roles. 
	protected var sensitivity = new AtomicInteger() // parameter
	protected var observerADN : AlgorithmInfo	
	protected var isMaster  = new AtomicBoolean(false)
	
	protected val listeners = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the client and the role 
	protected val providers = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the role and data providers
	protected var platformName : String
	protected var computation_location : String
	
	protected var checkList = Collections.synchronizedMap(new HashMap<String, Boolean>)
	
	protected var processingParameters = new ArrayList<String>
	
	@SuppressWarnings("potential_field_synchronization_problem")
	on Initialize {

		observerADN = occurrence.parameters.get(0) as AlgorithmInfo
		selfSpace.registerStrongParticipant(asEventListener) // listen to a self-internal space
		
		checkList.put("isCompLocationKnown", false)
		checkList.put("paramKnown", false)
		
		task("waiting-greenLights").every(1000)[
			if (areAllTrue(checkList.values)) {
				info("Start the processing role at location - "+computation_location+". Parameters are: s= "+sensitivity.get+ " isMaster=" + isMaster.get)
				startProcessingRole
				loggingName = this.ID + "-ALGORITHM-" + observerADN.name + "-" + observerADN.level + "-" + platformName + "-" + computation_location
				task("waiting-greenLights").cancel
			}
			else{
				debug("Waiting for command" + checkList)
			}
		]
	}

	on HyperParametersRequest {
		
		var providerID = occurrence.source.ID
		// We decide that derived role handles the parameters request of inner-agents. 
		//Removing the flag results in nullException as the role 
		//receives a request from a innerAgent but did not include it in its providers.
		
		if(!getMemberAgents.contains(providerID)){
			debug("param requests from agentID=" + providerID.toString.substring(0, 5) +
				" sending param:" + " s =" +sensitivity)
			emit(providers.get(providerID), new ProcessingHyperParameters(sensitivity.get, isMaster.get))[it.ID == providerID]}
		
	}
	on Destroy {
		//info("The behavior was stopped.")
}
	on ComputationalRessources {
		debug("received computation_location: " + occurrence.client_id)
		computation_location = occurrence.client_id
		checkList.put("isCompLocationKnown",true)
	}

	@SuppressWarnings("potential_field_synchronization_problem")
	on PlatformOrganizationInfo  { 
		platformContext = occurrence.context
		privatePlatformSpace = occurrence.privateCommunicationChannel
		privatePlatformSpace.registerStrongParticipant(asEventListener)
		platformName = occurrence.platformName
		observerADN.platformName = occurrence.platformName
		emit(platformContext.defaultSpace,new Identification(observerADN.name)) //@ FIXME not general in the sens of it should whenever it joins a context
	}	
	
	on TOLDOrganizationInfo {
		TOLDContext = occurrence.context
		privateTOLDSpace = occurrence.privateCommunicationChannel
		privateTOLDSpace.registerStrongParticipant(asEventListener)
	}

	@SuppressWarnings("potential_field_synchronization_problem")
	
	on AddMission {

		occurrence.communicationChannel.registerStrongParticipant(asEventListener)
		var missionSpace = occurrence.communicationChannel
		var clientID = occurrence.source.ID
		
		debug("requested to add mission with ID = " + (missionSpace.spaceID.toString.substring(0, 5)) + " from " +
			clientID.toString.substring(0, 5))
		listeners.put(clientID, missionSpace) // @FIXME maybe there is a huge misunderstanding of the use of Spaces, maybe we could have address which is simpler
		var accepted = true // @TODO develop criteria for the admission of the mission 
		if (accepted) {
			emit(missionSpace,new HyperParametersRequest)[it.ID == clientID]
			debug("requests missionParameters to " + clientID.toString.substring(0,5))
			}
	}
	/** 
	@SuppressWarnings("potential_field_synchronization_problem")
	on StopMission {
		if (listeners.keySet.contains(occurrence.source.ID)){
			info("I received the StopMission")
			listeners.remove(occurrence.source.ID)
		}
		else{
			info("I do not recognize the provider" + occurrence.expertID)
		}
	}
		@SuppressWarnings("potential_field_synchronization_problem")
		on LeavePlatform {
		//join(BaseContext.ID, BaseSpace.spaceID.ID)
		//info("ObserverLeaving")
		//leave(PlatformContext.ID)
	}*/
	on ProcessingHyperParameters {		
		sensitivity.set(occurrence.s)
		isMaster.set(occurrence.OptimalSearchEnabled)
		processingParameters.add(sensitivity.toString)
		checkList.put("paramKnown",true)
	}

	//@FIXME possibly a reaction of the global behavior observer. We could generalize.
	on SignalID {
		
		var sid = occurrence.signalID
		// Creation of a communication space between the data source and the role
		// @FIXME is it allowed to use the platform Context?
		if(!providers.containsKey(sid)){
			//info("Unkown signal" + sid)
			val comChannel = platformContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID)
			comChannel.registerStrongParticipant(asEventListener)
			providers.put(sid, comChannel)
			debug("Received provider ID sending the channel " + providers.get(sid).spaceID.ID)
			
			emit(platformContext.defaultSpace,new AddMission(providers.get(sid))) [it.ID == sid] //@FIXME check whether the defaultSPACE is platform //@FIXME Check a simpler way to send
		}
		else{
			debug("Known signal = " + sid)
			emit(providers.get(sid),new ResumeMission)[this.ID == sid]
			debug("Trying now in the default")
			emit(platformContext.defaultSpace,new ResumeMission)[it.ID==sid]
		}
	}
	
	synchronized def requestAlgorithm(algoName : String, algoTask : String) {
		
		emit(privatePlatformSpace, new AddObserver(
			new AlgorithmInfo(algoName, algoTask),
			new AlgorithmInfo(observerADN.name, observerADN.task)
		))[it.ID == platformContext.ID]
	}
	
	abstract def startProcessingRole()

 	synchronized def areAllTrue(array: boolean[]) {
 		for(b : array) if(!b) return false;
    	return true;
    }
}


