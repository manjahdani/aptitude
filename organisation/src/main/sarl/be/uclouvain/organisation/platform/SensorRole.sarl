/** 
 * 
 */
package be.uclouvain.organisation.platform

import be.uclouvain.organisation.platform.events.AddMission
import be.uclouvain.organisation.platform.events.HyperParametersRequest
import be.uclouvain.organisation.platform.events.ProcessingHyperParameters
import be.uclouvain.organisation.platform.events.Ready2Process
import be.uclouvain.organisation.platform.util.SurveillanceMissionData
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.Schedules
import java.util.ArrayList
import java.util.Collections
import java.util.HashMap
import java.util.UUID

/** 
 * @author manjah
 * 
 */
abstract behavior SensorRole extends ScenarioRole {
	uses Logging, Schedules, ExternalContextAccess, Behaviors, DefaultContextInteractions

	protected val listeners = Collections.synchronizedMap(new HashMap<UUID, OpenEventSpace>) // Private spaces between the client and the role
	protected val missionList = Collections.synchronizedMap(new HashMap<UUID, SurveillanceMissionData>) // A map between mission ID that it needs to answer to and their data
	
	on ProcessingHyperParameters {
		debug("param received " + "MID = " + occurrence.missionID + " hp " + occurrence.param.hyperParametersAsAString)
		missionList.get(occurrence.missionID).update(occurrence.param)
	}

	on AddMission {

		val missionSpace = retrieveOrCreateOpenSpaceWithID(occurrence.communicationChannelID)
		val clientID = occurrence.source.ID
		val missionID = occurrence.missionID
		//info("received mission request from "  + clientID + "\n sid = " + missionSpace.spaceID.ID + "\n mID = " + missionID )
		var accepted = true // @TODO LOW develop criteria for the admission of the mission
		if (accepted) {
			val newMission = new SurveillanceMissionData(missionID, clientID, organizationContext.get.ID)
			missionList.put(occurrence.missionID, newMission)
			listeners.put(clientID, missionSpace)
			missionSpace.registerStrongParticipant(asEventListener)
			waitMissionParam(occurrence.missionID)
			emit(missionSpace, new HyperParametersRequest(occurrence.missionID))[it.ID == clientID]
		}
	}


	
	override Ready2Process {
		emitToParent( new Ready2Process)
	}
	

	
	def waitMissionParam(mID : UUID) {

		task("rMP".concat(mID.toString)).every(1000) [
			val MD = missionList.get(mID)
			if (MD.hyperParameters.paramKnown) {
				info("Sensor - start the processing role for mid = " + mID+ "\n at location - " + ". Parameters are: s= " + MD.cautionLevel +
						" isMaster=" + MD.isDynamicAdaptationEnabled)
				processingMissionWithID(mID)
				loggingName = this.ID + "-ALGORITHM-" + ADN.get.name + "-" + ADN.get.level + "-" +
					ADN.get.platformName + "-" + computation_location
				task("rMP".concat(mID.toString)).cancel
			} else {
				//info("Waiting for command MID = " + mID + " hp " + MD.hyperParametersAsAString)
			}
		]
	}

	def processingMissionWithID(mID : UUID) {
		emit(selfSpace, new ProcessMission(missionList.get(mID)))
	}
	

	def enableDataAcquisition(mID : UUID, signals : ArrayList<String>, signalType : String) {

		for (s : signals) {
			info("Sensor request " + s + " as " + signalType)
			emit(selfSpace, new RecruitSignal(missionList.get(mID), s, signalType))
		}
	}

	def enableDataAcquisition(mID : UUID, signalType : String) {
			emit(selfSpace, new RecruitSignal(missionList.get(mID), signalType))
	}
	
	
}
