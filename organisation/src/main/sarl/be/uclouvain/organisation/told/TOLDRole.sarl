package be.uclouvain.organisation.told

import be.uclouvain.organisation.AddMember
import be.uclouvain.organisation.AuthorizationToJoinContext
import be.uclouvain.organisation.PlatformOrganisationInfo
import be.uclouvain.organisation.TOLDOrganisationInfo
import io.sarl.core.Behaviors
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.ExternalContextAccess
import io.sarl.core.InnerContextAccess
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.OpenEventSpace
import io.sarl.core.OpenEventSpaceSpecification
import java.util.HashMap
import java.util.UUID

/** 
 * Trusted Observations and Learning Database is a database aiming to achieve two goals. 
 * 
 *  - Storing the information communicated by a platform.  
 * 
 *  - Contains ground truth signals dedicated to learning.
 * 
 * @author $Author: manjahdani$
 * @version $0.0.2$
 * @date $16/04/2021$
 * @mavengroupid $be.uclouvain.aptitude$
 * @mavenartifactid $organisation$
 * 
 */
behavior TOLDRole {
	
	uses Behaviors, AccessDatabaseCapacity, InnerContextAccess,Logging, ExternalContextAccess, DefaultContextInteractions
	
	
	protected var platformID : UUID
	protected val privateSpacesListeners = new HashMap<UUID, OpenEventSpace>
	/*
	 * The platform registerStrongParticipant the context of a platform 
	 */

	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on AddEntry{
		debug("creating entry for " + occurrence.key.toString.substring(0,5))
		create(occurrence.key, occurrence.data)
	}
	on DeleteEntry{
		delete(occurrence.key)
	}
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on DataEntry {
		//info("Updating key : " + occurrence.key  +" - " + occurrence.class)
		update(occurrence.key, occurrence.data)
	}
	
	/*
	 * Send if available the stored data about it. 
	 */
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	
	on AddMember{
		debug("received add member from " + occurrence.source.ID.toString.substring(0, 5) + "to invite within my context " + occurrence.memberID)
		
		emit(occurrence.communicationChannel,
			new AuthorizationToJoinContext(this.ID, innerContext.defaultSpace.spaceID.ID))[it.ID==occurrence.memberID]
	}
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on ReadEntry {
		debug("Reading entry and sending -" + read(occurrence.key))
		emit(privateSpacesListeners.get(occurrence.source.ID), new QueryAnswer(read(occurrence.key)))
	}
	on MemberJoined {
		debug("MemberJoined - " + occurrence.agentID.toString.substring(0, 5))
		var memberID = occurrence.agentID;
		privateSpacesListeners.put(memberID,
			innerContext.getOrCreateSpaceWithID(OpenEventSpaceSpecification, UUID.randomUUID))
		
		
		if(occurrence.inDefaultSpace){
			emit(new TOLDOrganisationInfo(innerContext, privateSpacesListeners.get(memberID), read(memberID))) [
			it.ID == memberID]
		} 
		else {
			wake(new TOLDOrganisationInfo(innerContext, privateSpacesListeners.get(memberID), read(memberID))) [
				it.ID == memberID
			]
		}
		privateSpacesListeners.get(memberID).registerStrongParticipant(asEventListener)
	}

	on PlatformOrganisationInfo {
		debug("Platform organisation - " + occurrence.platformName + " encountered ")
		platformID = occurrence.source.ID
		if (!privateSpacesListeners.containsKey(platformID)){
			info("Platform was not encountered")
				val privateChannel = occurrence.privateCommunicationChannel
				privateSpacesListeners.put(platformID, privateChannel)
				privateChannel.registerStrongParticipant(asEventListener)
				emit(privateChannel,
					new TOLDOrganisationInfo(innerContext, privateSpacesListeners.get(platformID), read(platformID))) [
					it.ID == platformID
				]
		}	
	}
	@SuppressWarnings("discouraged_occurrence_readonly_use")
	on MemberLeft {
		privateSpacesListeners.remove(occurrence.agentID)
	}
}
